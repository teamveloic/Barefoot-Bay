import { sql } from "drizzle-orm";
import { db, pool } from "./db";
import session from "express-session";
import connectPg from "connect-pg-simple";
import { 
  users, events, realEstateListings, eventInteractions, eventComments, pageContents, contentVersions, listingPayments,
  products, orders, orderItems, customForms, formSubmissions, orderReturns, returnItems,
  forumCategories, forumPosts, forumComments, forumReactions, forumDescription, 
  vendorComments, vendorInteractions, vendorCategories, communityCategories,
  featureFlags, siteSettings, UserRole, FeatureFlagName,
  messages, messageRecipients, MessageType, MessageStatus,
  type User, type Event, type RealEstateListing, type EventInteraction, type EventComment,
  type InsertUser, type InsertEvent, type InsertListing, type InsertEventInteraction, type InsertEventComment,
  type PageContent, type InsertPageContent, type ContentVersion, type InsertContentVersion,
  type ListingPayment, type InsertListingPayment,
  type Product, type InsertProduct, type Order, type InsertOrder, type OrderItem, type InsertOrderItem,
  type CustomForm, type InsertCustomForm, type FormSubmission, type InsertFormSubmission,
  type OrderReturn, type InsertOrderReturn, type ReturnItem, type InsertReturnItem,
  type ForumCategory, type InsertForumCategory, type ForumPost, type InsertForumPost,
  type ForumComment, type InsertForumComment, type ForumReaction, type InsertForumReaction,
  type ForumDescription, type InsertForumDescription,
  type VendorComment, type InsertVendorComment, type VendorInteraction, type InsertVendorInteraction,
  type VendorCategory, type InsertVendorCategory, type CommunityCategory, type InsertCommunityCategory,
  type FeatureFlag, type InsertFeatureFlag, type SiteSetting, type InsertSiteSetting,
  type Message, type InsertMessage, type MessageRecipient, type InsertMessageRecipient
} from "../shared/schema";
import { eq, and, or, desc, asc, inArray, count, isNull, isNotNull, lt } from "drizzle-orm";
import * as fs from "fs";
import * as path from "path";

// Re-export db for direct use in routes
export { db };

const PostgresStore = connectPg(session);

export interface IStorage {
  // Direct database access for advanced operations
  getDb(): typeof db;
  
  // Database connection testing for diagnostics
  testDatabaseConnection(): Promise<{ success: boolean, message: string, timestamp: number }>;
  
  // Media persistence operations for deployment
  backupMediaFilesToDatabase(directories?: string[]): Promise<{
    backedUp: number,
    totalSize: number,
    skipped: number,
    errors: Array<{file: string, error: string}>
  }>;
  
  restoreMediaFilesFromDatabase(targetDir?: string): Promise<{
    restored: number,
    totalSize: number,
    errors: Array<{file: string, error: string}>
  }>;
  
  verifyBannerSlidePaths(): Promise<{
    updated: boolean,
    fixed?: number
  }>;
  
  verifyForumMediaPaths(): Promise<{
    updated: boolean,
    fixed?: number
  }>;
  
  verifyAvatarPaths(): Promise<{
    updated: boolean,
    fixed?: number
  }>;
  
  createMediaFilesTable(): Promise<boolean>;
  
  // Media and content cleaning operations
  previewUnusedMedia(): Promise<{
    filesToDelete: string[]
  }>;
  deleteUnusedMedia(fixMissingRefs?: boolean, specificFiles?: string[]): Promise<{ 
    deletedCount: number, 
    deletedFiles: string[],
    fixedReferences?: {
      count: number,
      items: Array<{table: string, id: number, field: string, originalUrls: string[]}>
    }
  }>;
  checkMissingMedia(): Promise<{
    missingCount: number,
    missingFiles: Array<{table: string, id: number, field: string, url: string}>
  }>;
  deleteOldContentVersions(): Promise<{ deletedCount: number }>;
  
  // User operations
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  getUserByUsernameCaseInsensitive(username: string): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  getUserByEmailCaseInsensitive(email: string): Promise<User | undefined>;
  getUserBySubscriptionId(subscriptionId: string): Promise<User | undefined>;
  getUsersBySubscriptionId(subscriptionId: string): Promise<User[]>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, data: Partial<User>): Promise<User>;
  deleteUser(id: number): Promise<boolean>;
  getUsers(forceRefresh?: boolean): Promise<User[]>;
  getUsersWithActiveSubscriptions(): Promise<User[]>;
  getUsersWithExpiredSubscriptions(currentDate: Date): Promise<User[]>;

  // Event operations
  getEvents(): Promise<Event[]>;
  getEvent(id: number): Promise<Event | undefined>;
  createEvent(event: InsertEvent): Promise<Event>;
  deleteEvent(id: number): Promise<void>;
  deleteAllEvents(): Promise<void>;
  updateEvent(id: number, data: Partial<Event>, editMode?: 'occurrence' | 'series'): Promise<Event>;

  // Event interaction operations
  getEventInteractions(eventId: number): Promise<EventInteraction[]>;
  getEventInteraction(eventId: number, userId: number, type: string): Promise<EventInteraction | undefined>;
  createEventInteraction(interaction: InsertEventInteraction): Promise<EventInteraction>;
  deleteEventInteraction(eventId: number, userId: number, type: string): Promise<void>;

  // Event comment operations
  getEventComments(eventId: number): Promise<EventComment[]>;
  createEventComment(comment: InsertEventComment): Promise<EventComment>;
  deleteEventComment(id: number, userId: number): Promise<void>;

  // Vendor comment operations
  getVendorComments(pageSlug: string): Promise<VendorComment[]>;
  createVendorComment(comment: InsertVendorComment): Promise<VendorComment>;
  deleteVendorComment(id: number, userId: number): Promise<void>;

  // Vendor interaction operations
  getVendorInteractions(pageSlug: string): Promise<VendorInteraction[]>;
  getVendorInteraction(pageSlug: string, userId: number, type: string): Promise<VendorInteraction | undefined>;
  createVendorInteraction(interaction: InsertVendorInteraction): Promise<VendorInteraction>;
  deleteVendorInteraction(pageSlug: string, userId: number, type: string): Promise<void>;
  deleteAllVendors(): Promise<void>;

  // Real estate operations
  getListings(): Promise<RealEstateListing[]>;
  getListing(id: number): Promise<RealEstateListing | undefined>;
  createListing(listing: InsertListing): Promise<RealEstateListing>;
  updateListing(id: number, data: Partial<RealEstateListing>): Promise<RealEstateListing>;
  deleteListing(id: number): Promise<void>;
  deleteAllListings(): Promise<void>;
  getExpiredListings(referenceDate?: Date): Promise<RealEstateListing[]>;
  getExpiringListings(daysUntilExpiration: number): Promise<RealEstateListing[]>;
  getUserListingsWithSubscriptions(userId: number): Promise<RealEstateListing[]>;
  getListingsByUser(userId: number): Promise<RealEstateListing[]>;
  getListingsBySubscriptionId(subscriptionId: string): Promise<RealEstateListing[]>;

  // Listing payment operations
  getListingPayment(id: number): Promise<ListingPayment | undefined>;
  getListingPaymentByIntent(paymentIntentId: string): Promise<ListingPayment | undefined>;
  createListingPayment(payment: InsertListingPayment): Promise<ListingPayment>;
  updateListingPayment(id: number, data: Partial<ListingPayment>): Promise<ListingPayment>;
  getListingPaymentsByListing(listingId: number): Promise<ListingPayment[]>;
  getListingPaymentsBySubscription(subscriptionId: string): Promise<ListingPayment[]>;

  // Store product operations
  getProducts(): Promise<Product[]>;
  getProductsByCategory(category: string): Promise<Product[]>;
  getFeaturedProducts(): Promise<Product[]>;
  getProduct(id: number): Promise<Product | undefined>;
  createProduct(product: InsertProduct): Promise<Product>;
  updateProduct(id: number, data: Partial<Product>): Promise<Product>;
  deleteProduct(id: number): Promise<void>;
  deleteAllProducts(): Promise<void>;

  // Order operations
  getOrders(): Promise<Order[]>;
  getUserOrders(userId: number): Promise<Order[]>;
  getOrdersByStatus(statuses: string[]): Promise<Order[]>;
  getOrder(id: number): Promise<Order | undefined>;
  createOrder(order: InsertOrder): Promise<Order>;
  updateOrder(id: number, data: Partial<Order>): Promise<Order>;
  deleteOrder(id: number): Promise<void>;
  
  // Order item operations
  getOrderItems(orderId: number): Promise<OrderItem[]>;
  createOrderItem(orderItem: InsertOrderItem): Promise<OrderItem>;
  deleteOrderItem(id: number): Promise<void>;
  
  // Order return operations
  getOrderReturns(): Promise<OrderReturn[]>;
  getOrderReturnsByStatus(statuses: string[]): Promise<OrderReturn[]>;
  getOrderReturnsByOrder(orderId: number): Promise<OrderReturn[]>;
  getOrderReturnsByUser(userId: number): Promise<OrderReturn[]>;
  getOrderReturn(id: number): Promise<OrderReturn | undefined>;
  createOrderReturn(orderReturn: InsertOrderReturn): Promise<OrderReturn>;
  updateOrderReturn(id: number, data: Partial<OrderReturn>): Promise<OrderReturn>;
  deleteOrderReturn(id: number): Promise<void>;
  
  // Return item operations
  getReturnItems(returnId: number): Promise<ReturnItem[]>;
  getReturnItem(id: number): Promise<ReturnItem | undefined>;
  createReturnItem(returnItem: InsertReturnItem): Promise<ReturnItem>;
  updateReturnItem(id: number, data: Partial<ReturnItem>): Promise<ReturnItem>;
  deleteReturnItem(id: number): Promise<void>;
  
  // Message operations
  getMessage(id: number): Promise<Message | undefined>;
  getMessageWithRecipients(id: number): Promise<(Message & { recipients: MessageRecipient[] }) | undefined>;
  getMessageRecipients(messageId: number): Promise<(MessageRecipient & { user?: Partial<User> })[]>;
  createMessage(message: InsertMessage, recipients: { recipientId: number, targetRole?: string }[]): Promise<Message>;
  createBroadcastMessage(message: InsertMessage, targetRole: string): Promise<Message>;
  deleteMessage(id: number): Promise<boolean>;
  getSentMessages(userId: number, page?: number, limit?: number): Promise<Message[]>;
  getReceivedMessages(userId: number, status?: string, page?: number, limit?: number): Promise<MessageRecipient[]>;
  getUnreadMessageCount(userId: number): Promise<number>;
  markMessageAsRead(messageId: number, userId: number): Promise<boolean>;
  markMessageAsArchived(messageId: number, userId: number): Promise<boolean>;

  sessionStore: session.Store;
  // Page content operations
  getPageContent(slug: string, includeHidden?: boolean): Promise<PageContent | undefined>;
  getAllPageContents(includeHidden?: boolean): Promise<PageContent[]>;
  createPageContent(content: InsertPageContent): Promise<PageContent>;
  updatePageContent(id: number, data: Partial<PageContent>, options?: { createVersion?: boolean; versionNotes?: string }): Promise<PageContent>;
  deletePageContent(id: number): Promise<boolean>;
  deleteCommunityPages(): Promise<{ count: number, deletedIds: number[] }>;
  updatePageSlugsForCategoryChange(oldSlug: string, newSlug: string): Promise<{ count: number, updatedIds: number[] }>;
  
  // Content version history operations
  getContentVersions(contentId: number): Promise<ContentVersion[]>;
  getContentVersionsBySlug(slug: string): Promise<ContentVersion[]>;
  createContentVersion(version: InsertContentVersion): Promise<ContentVersion>;
  restoreContentVersion(versionId: number): Promise<PageContent>;
  
  // Custom forms operations
  getCustomForms(): Promise<CustomForm[]>;
  getCustomForm(id: number): Promise<CustomForm | undefined>;
  getCustomFormBySlug(slug: string): Promise<CustomForm | undefined>;
  createCustomForm(form: InsertCustomForm): Promise<CustomForm>;
  updateCustomForm(id: number, data: Partial<CustomForm>): Promise<CustomForm>;
  deleteCustomForm(id: number): Promise<boolean>;
  
  // Form submissions operations
  getFormSubmissions(formId: number): Promise<FormSubmission[]>;
  getAllFormSubmissions(): Promise<FormSubmission[]>;
  getFormSubmission(id: number): Promise<FormSubmission | undefined>;
  createFormSubmission(submission: InsertFormSubmission): Promise<FormSubmission>;
  
  // Forum category operations
  getForumCategories(): Promise<ForumCategory[]>;
  getForumCategory(id: number): Promise<ForumCategory | undefined>;
  getForumCategoryBySlug(slug: string): Promise<ForumCategory | undefined>;
  createForumCategory(category: InsertForumCategory): Promise<ForumCategory>;
  updateForumCategory(id: number, data: Partial<ForumCategory>): Promise<ForumCategory>;
  deleteForumCategory(id: number): Promise<void>;
  
  // Forum post operations
  getForumPosts(categoryId?: number): Promise<ForumPost[]>;
  getForumPost(id: number): Promise<ForumPost | undefined>;
  createForumPost(post: InsertForumPost): Promise<ForumPost>;
  updateForumPost(id: number, data: Partial<ForumPost>): Promise<ForumPost>;
  deleteForumPost(id: number): Promise<void>;
  incrementPostViews(id: number): Promise<ForumPost>;
  
  // Forum comment operations
  getForumComments(postId: number): Promise<ForumComment[]>;
  getForumComment(id: number): Promise<ForumComment | undefined>;
  createForumComment(comment: InsertForumComment): Promise<ForumComment>;
  updateForumComment(id: number, data: Partial<ForumComment>): Promise<ForumComment>;
  deleteForumComment(id: number): Promise<void>;
  
  // Forum reaction operations
  getForumReactions(postId?: number, commentId?: number): Promise<ForumReaction[]>;
  createForumReaction(reaction: InsertForumReaction): Promise<ForumReaction>;
  deleteForumReaction(id: number): Promise<void>;
  getForumReactionByUser(userId: number, postId?: number, commentId?: number): Promise<ForumReaction | undefined>;
  
  // Forum description operations
  getForumDescription(): Promise<ForumDescription | undefined>;
  createForumDescription(description: InsertForumDescription): Promise<ForumDescription>;
  updateForumDescription(id: number, data: Partial<ForumDescription>): Promise<ForumDescription>;

  // Forum bulk operations
  deleteAllForumContent(): Promise<{ deletedReactions: number, deletedComments: number, deletedPosts: number }>;
  deleteAllForumComments(): Promise<{ deletedReactions: number, deletedComments: number }>;
  

  // Vendor category operations
  getVendorCategories(includeHidden?: boolean): Promise<VendorCategory[]>;
  getVendorCategory(id: number): Promise<VendorCategory | undefined>;
  getVendorCategoryBySlug(slug: string): Promise<VendorCategory | undefined>;
  createVendorCategory(category: InsertVendorCategory): Promise<VendorCategory>;
  updateVendorCategory(id: number, data: Partial<VendorCategory>): Promise<VendorCategory>;
  deleteVendorCategory(id: number): Promise<void>;
  updatePageSlugsForVendorCategoryChange(oldSlug: string, newSlug: string): Promise<{ count: number, updatedIds: number[] }>;
  
  // Community category operations
  getCommunityCategories(): Promise<CommunityCategory[]>;
  getCommunityCategory(id: number): Promise<CommunityCategory | undefined>;
  getCommunityCategoryBySlug(slug: string): Promise<CommunityCategory | undefined>;
  createCommunityCategory(category: InsertCommunityCategory): Promise<CommunityCategory>;
  updateCommunityCategory(id: number, data: Partial<CommunityCategory>): Promise<CommunityCategory>;
  deleteCommunityCategory(id: number): Promise<void>;
  updatePageSlugsForCategoryChange(oldSlug: string, newSlug: string): Promise<{ count: number, updatedIds: number[] }>;
  
  // Feature flag operations
  getFeatureFlags(): Promise<FeatureFlag[]>;
  getFeatureFlag(id: number): Promise<FeatureFlag | undefined>;
  getFeatureFlagByName(name: string): Promise<FeatureFlag | undefined>;
  createFeatureFlag(featureFlag: InsertFeatureFlag): Promise<FeatureFlag>;
  updateFeatureFlag(id: number, data: Partial<FeatureFlag>): Promise<FeatureFlag>;
  deleteFeatureFlag(id: number): Promise<void>;
  getVisibleFeaturesForRole(role: string): Promise<FeatureFlag[]>;
  initializeDefaultFeatureFlags(): Promise<FeatureFlag[]>;
  
  // Site settings operations
  getSiteSettings(): Promise<SiteSetting[]>;
  getSiteSetting(id: number): Promise<SiteSetting | undefined>;
  getSiteSettingByKey(key: string): Promise<SiteSetting | undefined>;
  setSiteSetting(key: string, value: string, description?: string, userId?: number): Promise<SiteSetting>;
  deleteSiteSetting(id: number): Promise<boolean>;
  getSettingValue(key: string): Promise<string | null>;
}

export class DatabaseStorage implements IStorage {
  sessionStore: session.Store;

  constructor() {
    this.sessionStore = new PostgresStore({
      pool,
      tableName: 'session',
      createTableIfMissing: true
    });
  }
  
  // Subscription-related user methods
  async getUserBySubscriptionId(subscriptionId: string): Promise<User | undefined> {
    console.log(`Storage: Getting user with subscription ID: ${subscriptionId}`);
    try {
      if (!subscriptionId) {
        console.error("Storage: Invalid subscription ID");
        throw new Error("Invalid subscription ID");
      }
      
      const results = await db.select().from(users)
        .where(eq(users.subscriptionId, subscriptionId));
      
      if (results.length === 0) {
        console.log(`Storage: No user found with subscription ID: ${subscriptionId}`);
        return undefined;
      }
      
      console.log(`Storage: Found user with ID: ${results[0].id} for subscription: ${subscriptionId}`);
      return results[0];
    } catch (error) {
      console.error("Storage: Error getting user by subscription ID:", error);
      throw error;
    }
  }
  
  async getUsersBySubscriptionId(subscriptionId: string): Promise<User[]> {
    console.log(`Storage: Getting users with subscription ID: ${subscriptionId}`);
    try {
      if (!subscriptionId) {
        console.error("Storage: Invalid subscription ID");
        throw new Error("Invalid subscription ID");
      }
      
      const results = await db.select().from(users)
        .where(eq(users.subscriptionId, subscriptionId));
      
      console.log(`Storage: Found ${results.length} users with subscription ID: ${subscriptionId}`);
      return results;
    } catch (error) {
      console.error("Storage: Error getting users by subscription ID:", error);
      throw error;
    }
  }
  
  async getUsersWithActiveSubscriptions(): Promise<User[]> {
    console.log("Storage: Getting all users with active subscriptions");
    try {
      const results = await db.select().from(users)
        .where(eq(users.subscriptionStatus, 'active'));
      
      console.log(`Storage: Found ${results.length} users with active subscriptions`);
      return results;
    } catch (error) {
      console.error("Storage: Error getting users with active subscriptions:", error);
      throw error;
    }
  }
  
  async getUsersWithExpiredSubscriptions(currentDate: Date): Promise<User[]> {
    console.log(`Storage: Getting users with expired subscriptions as of ${currentDate.toISOString()}`);
    try {
      // Find users with:
      // 1. A subscription end date that's in the past
      // 2. Currently marked as 'active' or 'cancelled' subscription status
      // 3. Currently have the 'paid' role
      
      const results = await db.select().from(users)
        .where(
          and(
            // Must have a subscription ID and end date
            isNotNull(users.subscriptionId),
            isNotNull(users.subscriptionEndDate),
            // Subscription end date is in the past
            lt(users.subscriptionEndDate, currentDate),
            // Status is still active or cancelled (not yet marked as expired)
            or(
              eq(users.subscriptionStatus, 'active'),
              eq(users.subscriptionStatus, 'cancelled')
            )
          )
        );
      
      console.log(`Storage: Found ${results.length} users with expired subscriptions`);
      return results;
    } catch (error) {
      console.error("Storage: Error getting users with expired subscriptions:", error);
      throw error;
    }
  }
  
  // Direct database access for raw SQL operations
  getDb(): typeof db {
    return db;
  }
  
  /**
   * Create media_files table for storing binary file data during deployments
   */
  async createMediaFilesTable(): Promise<boolean> {
    try {
      console.log('Creating or checking media_files table...');
      
      // Check if the table already exists
      const tableExists = await pool.query(`
        SELECT EXISTS (
          SELECT FROM information_schema.tables 
          WHERE table_schema = 'public' 
          AND table_name = 'media_files'
        );
      `);
      
      if (tableExists.rows[0].exists) {
        console.log('media_files table already exists');
        return true;
      }
      
      // Create the table if it doesn't exist
      await pool.query(`
        CREATE TABLE media_files (
          id SERIAL PRIMARY KEY,
          filename TEXT NOT NULL,
          directory TEXT NOT NULL,
          file_data BYTEA NOT NULL,
          file_size BIGINT NOT NULL,
          mime_type TEXT,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        );
      `);
      
      console.log('media_files table created successfully');
      return true;
    } catch (error) {
      console.error('Error creating media_files table:', error);
      return false;
    }
  }
  
  /**
   * Backup media files to database for persistence during deployments
   * @param directories Optional specific directories to backup
   * @returns Backup statistics
   */
  async backupMediaFilesToDatabase(directories?: string[]): Promise<{
    backedUp: number,
    totalSize: number,
    skipped: number,
    errors: Array<{file: string, error: string}>
  }> {
    try {
      // Create table if it doesn't exist
      await this.createMediaFilesTable();
      
      // Default directories to scan if none provided
      const dirsToScan = directories || [
        'banner-slides',
        'uploads/banner-slides',
        'forum-media', 
        'uploads/forum-media',
        'avatars',
        'uploads/avatars',
        'calendar',
        'uploads/calendar'
      ];
      
      let backedUp = 0;
      let totalSize = 0;
      let skipped = 0;
      const errors: Array<{file: string, error: string}> = [];
      
      // Process each directory
      for (const dir of dirsToScan) {
        console.log(`Scanning directory: ${dir}`);
        
        try {
          // Skip if directory doesn't exist
          if (!fs.existsSync(dir)) {
            console.log(`Directory does not exist: ${dir}`);
            continue;
          }
          
          // Get all files in directory
          const files = fs.readdirSync(dir).filter(file => 
            !fs.statSync(path.join(dir, file)).isDirectory()
          );
          
          console.log(`Found ${files.length} files in ${dir}`);
          
          // Process each file
          for (const filename of files) {
            const filePath = path.join(dir, filename);
            
            try {
              // Get file stats
              const stats = fs.statSync(filePath);
              if (stats.isDirectory()) continue;
              
              // Read file data
              const fileData = fs.readFileSync(filePath);
              
              // Detect MIME type based on extension
              const ext = path.extname(filename).toLowerCase();
              let mimeType = 'application/octet-stream';
              
              if (ext === '.jpg' || ext === '.jpeg') mimeType = 'image/jpeg';
              else if (ext === '.png') mimeType = 'image/png';
              else if (ext === '.gif') mimeType = 'image/gif';
              else if (ext === '.webp') mimeType = 'image/webp';
              else if (ext === '.mp4') mimeType = 'video/mp4';
              else if (ext === '.webm') mimeType = 'video/webm';
              else if (ext === '.svg') mimeType = 'image/svg+xml';
              
              // Check if file already exists in database
              const existingFile = await pool.query(
                'SELECT id, file_size FROM media_files WHERE filename = $1 AND directory = $2',
                [filename, dir]
              );
              
              if (existingFile.rows.length > 0) {
                // If file size is the same, skip it
                if (existingFile.rows[0].file_size === fileData.length) {
                  console.log(`Skipping unchanged file: ${filePath}`);
                  skipped++;
                  continue;
                }
                
                // Otherwise update the existing record
                await pool.query(
                  'UPDATE media_files SET file_data = $1, file_size = $2, mime_type = $3, updated_at = NOW() WHERE id = $4',
                  [fileData, fileData.length, mimeType, existingFile.rows[0].id]
                );
                
                console.log(`Updated existing file in database: ${filePath}`);
              } else {
                // Insert new record
                await pool.query(
                  'INSERT INTO media_files (filename, directory, file_data, file_size, mime_type) VALUES ($1, $2, $3, $4, $5)',
                  [filename, dir, fileData, fileData.length, mimeType]
                );
                
                console.log(`Backed up file to database: ${filePath}`);
              }
              
              backedUp++;
              totalSize += fileData.length;
              
            } catch (fileError) {
              console.error(`Error processing file ${filePath}:`, fileError);
              errors.push({
                file: filePath,
                error: fileError instanceof Error ? fileError.message : String(fileError)
              });
            }
          }
        } catch (dirError) {
          console.error(`Error processing directory ${dir}:`, dirError);
          errors.push({
            file: dir,
            error: dirError instanceof Error ? dirError.message : String(dirError)
          });
        }
      }
      
      return { backedUp, totalSize, skipped, errors };
    } catch (error) {
      console.error('Error backing up media files:', error);
      return {
        backedUp: 0,
        totalSize: 0,
        skipped: 0,
        errors: [{
          file: 'general',
          error: error instanceof Error ? error.message : String(error)
        }]
      };
    }
  }
  
  /**
   * Restore media files from database after deployment
   * @param targetDir Optional specific target directory
   * @returns Restore statistics
   */
  async restoreMediaFilesFromDatabase(targetDir?: string): Promise<{
    restored: number,
    totalSize: number,
    errors: Array<{file: string, error: string}>
  }> {
    try {
      console.log('Restoring media files from database...');
      
      let query = 'SELECT * FROM media_files';
      const queryParams: any[] = [];
      
      // Filter by target directory if specified
      if (targetDir) {
        query += ' WHERE directory = $1';
        queryParams.push(targetDir);
      }
      
      // Get all files from database
      const result = await pool.query(query, queryParams);
      
      let restored = 0;
      let totalSize = 0;
      const errors: Array<{file: string, error: string}> = [];
      
      // Process each file
      for (const row of result.rows) {
        const dirPath = row.directory;
        const filePath = path.join(dirPath, row.filename);
        
        try {
          // Ensure directory exists
          if (!fs.existsSync(dirPath)) {
            fs.mkdirSync(dirPath, { recursive: true });
            console.log(`Created directory: ${dirPath}`);
          }
          
          // Write file to disk
          fs.writeFileSync(filePath, row.file_data);
          console.log(`Restored file: ${filePath}`);
          
          restored++;
          totalSize += Number(row.file_size);
        } catch (fileError) {
          console.error(`Error restoring file ${filePath}:`, fileError);
          errors.push({
            file: filePath,
            error: fileError instanceof Error ? fileError.message : String(fileError)
          });
        }
      }
      
      return { restored, totalSize, errors };
    } catch (error) {
      console.error('Error restoring media files:', error);
      return {
        restored: 0,
        totalSize: 0,
        errors: [{
          file: 'general',
          error: error instanceof Error ? error.message : String(error)
        }]
      };
    }
  }
  
  /**
   * Verify banner slide paths in database and ensure they match existing files
   */
  async verifyBannerSlidePaths(): Promise<{
    updated: boolean,
    fixed?: number
  }> {
    try {
      console.log('Verifying banner slide paths in database...');
      
      // Get banner slides content
      const result = await pool.query(
        "SELECT id, content FROM page_contents WHERE slug = 'banner-slides'"
      );
      
      if (result.rows.length === 0) {
        console.log('No banner slides found in database');
        return { updated: false };
      }
      
      const pageContent = result.rows[0];
      let slides;
      
      try {
        slides = JSON.parse(pageContent.content);
      } catch (error) {
        console.error('Error parsing banner slides JSON:', error);
        return { updated: false };
      }
      
      if (!Array.isArray(slides) || slides.length === 0) {
        console.log('No banner slides found or content is not an array');
        return { updated: false };
      }
      
      console.log(`Found ${slides.length} banner slides to verify`);
      let updatedCount = 0;
      let updatedSlides = false;
      
      // Process each slide and ensure correct path formats
      const newSlides = slides.map(slide => {
        // Skip if no source
        if (!slide.src) return slide;
        
        const newSlide = { ...slide };
        let fileExists = false;
        
        // Handle /banner-slides/ paths
        if (newSlide.src.startsWith('/banner-slides/')) {
          const filename = newSlide.src.replace('/banner-slides/', '');
          const fullPath = path.join('banner-slides', filename);
          
          if (fs.existsSync(fullPath)) {
            console.log(`File exists at path: ${fullPath}`);
            fileExists = true;
          } else {
            // Try uploads path
            const uploadsPath = path.join('uploads/banner-slides', filename);
            if (fs.existsSync(uploadsPath)) {
              // File exists in uploads but not in root, copy it
              try {
                // Ensure directory exists
                if (!fs.existsSync('banner-slides')) {
                  fs.mkdirSync('banner-slides', { recursive: true });
                }
                fs.copyFileSync(uploadsPath, fullPath);
                console.log(`Copied file from uploads to banner-slides: ${filename}`);
                fileExists = true;
                updatedSlides = true;
                updatedCount++;
              } catch (copyError) {
                console.error(`Error copying file ${filename}:`, copyError);
              }
            } else {
              console.log(`Banner slide file not found: ${filename}`);
            }
          }
        }
        
        // Handle /uploads/banner-slides/ paths
        else if (newSlide.src.startsWith('/uploads/banner-slides/')) {
          const filename = newSlide.src.replace('/uploads/banner-slides/', '');
          const fullPath = path.join('uploads/banner-slides', filename);
          
          if (fs.existsSync(fullPath)) {
            console.log(`File exists at path: ${fullPath}`);
            fileExists = true;
          } else {
            // Try non-uploads path
            const rootPath = path.join('banner-slides', filename);
            if (fs.existsSync(rootPath)) {
              // File exists in root but not in uploads, copy it
              try {
                // Ensure directory exists
                if (!fs.existsSync('uploads/banner-slides')) {
                  fs.mkdirSync('uploads/banner-slides', { recursive: true });
                }
                fs.copyFileSync(rootPath, fullPath);
                console.log(`Copied file from banner-slides to uploads: ${filename}`);
                fileExists = true;
                updatedSlides = true;
                updatedCount++;
              } catch (copyError) {
                console.error(`Error copying file ${filename}:`, copyError);
              }
            } else {
              console.log(`Banner slide file not found: ${filename}`);
            }
          }
        }
        
        // Return original slide if everything is OK
        return newSlide;
      });
      
      // Only update if changes were made
      if (updatedSlides) {
        await pool.query(
          'UPDATE page_contents SET content = $1, updated_at = NOW() WHERE id = $2',
          [JSON.stringify(newSlides), pageContent.id]
        );
        console.log('Updated banner slides paths in database');
      } else {
        console.log('No changes needed for banner slides paths');
      }
      
      return { updated: updatedSlides, fixed: updatedCount };
    } catch (error) {
      console.error('Error verifying banner slide paths:', error);
      return { updated: false };
    }
  }
  
  /**
   * Verify forum media paths in database and ensure they match existing files
   */
  async verifyForumMediaPaths(): Promise<{
    updated: boolean,
    fixed?: number
  }> {
    try {
      console.log('Verifying forum media paths in database...');
      
      // Track updated records
      let updatedCount = 0;
      let updatedRecords = false;
      
      // Get forum posts that contain media URLs
      const postResults = await pool.query(`
        SELECT id, content FROM forum_posts 
        WHERE content LIKE '%/forum-media/%' OR content LIKE '%/uploads/forum-media/%'
      `);
      
      console.log(`Found ${postResults.rows.length} forum posts with potential media references`);
      
      // Update forum posts
      for (const post of postResults.rows) {
        let content = post.content;
        let updated = false;
        
        // Process /forum-media/ paths
        for (const match of content.matchAll(/src="(\/forum-media\/[^"]+)"/g)) {
          const mediaPath = match[1];
          const filename = mediaPath.replace('/forum-media/', '');
          const fullPath = path.join('forum-media', filename);
          
          if (!fs.existsSync(fullPath)) {
            // Try uploads path
            const uploadsPath = path.join('uploads/forum-media', filename);
            if (fs.existsSync(uploadsPath)) {
              // File exists in uploads but not in root, copy it
              try {
                // Ensure directory exists
                if (!fs.existsSync('forum-media')) {
                  fs.mkdirSync('forum-media', { recursive: true });
                }
                fs.copyFileSync(uploadsPath, fullPath);
                console.log(`Copied file from uploads to forum-media: ${filename}`);
                updated = true;
                updatedCount++;
              } catch (copyError) {
                console.error(`Error copying file ${filename}:`, copyError);
              }
            } else {
              console.log(`Forum media file not found: ${filename}`);
            }
          }
        }
        
        // Process /uploads/forum-media/ paths
        for (const match of content.matchAll(/src="(\/uploads\/forum-media\/[^"]+)"/g)) {
          const mediaPath = match[1];
          const filename = mediaPath.replace('/uploads/forum-media/', '');
          const fullPath = path.join('uploads/forum-media', filename);
          
          if (!fs.existsSync(fullPath)) {
            // Try non-uploads path
            const rootPath = path.join('forum-media', filename);
            if (fs.existsSync(rootPath)) {
              // File exists in root but not in uploads, copy it
              try {
                // Ensure directory exists
                if (!fs.existsSync('uploads/forum-media')) {
                  fs.mkdirSync('uploads/forum-media', { recursive: true });
                }
                fs.copyFileSync(rootPath, fullPath);
                console.log(`Copied file from forum-media to uploads: ${filename}`);
                updated = true;
                updatedCount++;
              } catch (copyError) {
                console.error(`Error copying file ${filename}:`, copyError);
              }
            } else {
              console.log(`Forum media file not found: ${filename}`);
            }
          }
        }
        
        // Update post if changes were made
        if (updated) {
          await pool.query(
            'UPDATE forum_posts SET content = $1, updated_at = NOW() WHERE id = $2',
            [content, post.id]
          );
          updatedRecords = true;
          console.log(`Updated forum post ${post.id} with fixed media paths`);
        }
      }
      
      // Get forum comments that contain media URLs
      const commentResults = await pool.query(`
        SELECT id, content FROM forum_comments 
        WHERE content LIKE '%/forum-media/%' OR content LIKE '%/uploads/forum-media/%'
      `);
      
      console.log(`Found ${commentResults.rows.length} forum comments with potential media references`);
      
      // Update forum comments
      for (const comment of commentResults.rows) {
        let content = comment.content;
        let updated = false;
        
        // Process /forum-media/ paths (same logic as above)
        for (const match of content.matchAll(/src="(\/forum-media\/[^"]+)"/g)) {
          const mediaPath = match[1];
          const filename = mediaPath.replace('/forum-media/', '');
          const fullPath = path.join('forum-media', filename);
          
          if (!fs.existsSync(fullPath)) {
            // Try uploads path
            const uploadsPath = path.join('uploads/forum-media', filename);
            if (fs.existsSync(uploadsPath)) {
              // File exists in uploads but not in root, copy it
              try {
                // Ensure directory exists
                if (!fs.existsSync('forum-media')) {
                  fs.mkdirSync('forum-media', { recursive: true });
                }
                fs.copyFileSync(uploadsPath, fullPath);
                console.log(`Copied file from uploads to forum-media: ${filename}`);
                updated = true;
                updatedCount++;
              } catch (copyError) {
                console.error(`Error copying file ${filename}:`, copyError);
              }
            } else {
              console.log(`Forum media file not found: ${filename}`);
            }
          }
        }
        
        // Process /uploads/forum-media/ paths (same logic as above)
        for (const match of content.matchAll(/src="(\/uploads\/forum-media\/[^"]+)"/g)) {
          const mediaPath = match[1];
          const filename = mediaPath.replace('/uploads/forum-media/', '');
          const fullPath = path.join('uploads/forum-media', filename);
          
          if (!fs.existsSync(fullPath)) {
            // Try non-uploads path
            const rootPath = path.join('forum-media', filename);
            if (fs.existsSync(rootPath)) {
              // File exists in root but not in uploads, copy it
              try {
                // Ensure directory exists
                if (!fs.existsSync('uploads/forum-media')) {
                  fs.mkdirSync('uploads/forum-media', { recursive: true });
                }
                fs.copyFileSync(rootPath, fullPath);
                console.log(`Copied file from forum-media to uploads: ${filename}`);
                updated = true;
                updatedCount++;
              } catch (copyError) {
                console.error(`Error copying file ${filename}:`, copyError);
              }
            } else {
              console.log(`Forum media file not found: ${filename}`);
            }
          }
        }
        
        // Update comment if changes were made
        if (updated) {
          await pool.query(
            'UPDATE forum_comments SET content = $1, updated_at = NOW() WHERE id = $2',
            [content, comment.id]
          );
          updatedRecords = true;
          console.log(`Updated forum comment ${comment.id} with fixed media paths`);
        }
      }
      
      return { updated: updatedRecords, fixed: updatedCount };
    } catch (error) {
      console.error('Error verifying forum media paths:', error);
      return { updated: false };
    }
  }
  
  /**
   * Verify avatar paths in user profiles and ensure they match existing files
   */
  async verifyAvatarPaths(): Promise<{
    updated: boolean,
    fixed?: number
  }> {
    try {
      console.log('Verifying avatar paths in user profiles...');
      
      // Get users with avatar URLs
      const result = await pool.query(`
        SELECT id, "avatarUrl" FROM users 
        WHERE "avatarUrl" IS NOT NULL AND "avatarUrl" != ''
      `);
      
      console.log(`Found ${result.rows.length} users with avatar URLs`);
      
      let updatedCount = 0;
      let updatedRecords = false;
      
      // Process each user
      for (const user of result.rows) {
        const avatarUrl = user.avatarUrl;
        
        // Skip if no avatar URL
        if (!avatarUrl) continue;
        
        // Process /avatars/ paths
        if (avatarUrl.startsWith('/avatars/')) {
          const filename = avatarUrl.replace('/avatars/', '');
          const fullPath = path.join('avatars', filename);
          
          if (!fs.existsSync(fullPath)) {
            // Try uploads path
            const uploadsPath = path.join('uploads/avatars', filename);
            if (fs.existsSync(uploadsPath)) {
              // File exists in uploads but not in root, copy it
              try {
                // Ensure directory exists
                if (!fs.existsSync('avatars')) {
                  fs.mkdirSync('avatars', { recursive: true });
                }
                fs.copyFileSync(uploadsPath, fullPath);
                console.log(`Copied avatar from uploads to avatars: ${filename}`);
                updatedRecords = true;
                updatedCount++;
              } catch (copyError) {
                console.error(`Error copying avatar ${filename}:`, copyError);
              }
            } else {
              console.log(`Avatar file not found: ${filename}`);
            }
          }
        }
        
        // Process /uploads/avatars/ paths
        else if (avatarUrl.startsWith('/uploads/avatars/')) {
          const filename = avatarUrl.replace('/uploads/avatars/', '');
          const fullPath = path.join('uploads/avatars', filename);
          
          if (!fs.existsSync(fullPath)) {
            // Try non-uploads path
            const rootPath = path.join('avatars', filename);
            if (fs.existsSync(rootPath)) {
              // File exists in root but not in uploads, copy it
              try {
                // Ensure directory exists
                if (!fs.existsSync('uploads/avatars')) {
                  fs.mkdirSync('uploads/avatars', { recursive: true });
                }
                fs.copyFileSync(rootPath, fullPath);
                console.log(`Copied avatar from avatars to uploads: ${filename}`);
                updatedRecords = true;
                updatedCount++;
              } catch (copyError) {
                console.error(`Error copying avatar ${filename}:`, copyError);
              }
            } else {
              console.log(`Avatar file not found: ${filename}`);
            }
          }
        }
      }
      
      return { updated: updatedRecords, fixed: updatedCount };
    } catch (error) {
      console.error('Error verifying avatar paths:', error);
      return { updated: false };
    }
  }
  
  // Database connection test for diagnostics
  async testDatabaseConnection(): Promise<{ success: boolean, message: string, timestamp: number }> {
    console.log("Testing database connection");
    const timestamp = Date.now();
    
    try {
      // Get a client from the pool
      const client = await pool.connect();
      
      try {
        // Run a simple query
        const result = await client.query('SELECT NOW() as current_time');
        const dbTime = result.rows[0]?.current_time;
        
        console.log("Database connection successful, server time:", dbTime);
        return {
          success: true,
          message: `Connection successful. Database time: ${dbTime}`,
          timestamp
        };
      } catch (queryError) {
        console.error("Database query error:", queryError);
        return {
          success: false,
          message: `Query failed: ${queryError instanceof Error ? queryError.message : String(queryError)}`,
          timestamp
        };
      } finally {
        // Always release the client
        client.release();
      }
    } catch (connectionError) {
      console.error("Database connection error:", connectionError);
      return {
        success: false,
        message: `Connection failed: ${connectionError instanceof Error ? connectionError.message : String(connectionError)}`,
        timestamp
      };
    }
  }
  
  // Product operations
  async getProducts(): Promise<Product[]> {
    console.log("Getting all products");
    try {
      const results = await db.select().from(products);
      console.log("Products retrieved successfully");
      return results;
    } catch (error) {
      console.error("Error retrieving products:", error);
      throw error;
    }
  }

  async getProductsByCategory(category: string): Promise<Product[]> {
    console.log("Getting products by category:", category);
    try {
      // If the category is 'all', return all active products
      if (category === 'all') {
        const results = await db.select().from(products)
          .where(eq(products.status, 'active'));
        console.log(`Retrieved ${results.length} products (all categories)`);
        return results;
      }
      
      // If the category is 'featured', return empty array - FEATURED section removal
      if (category === 'featured') {
        console.log('Featured category requested but returning empty array (Featured section removal)');
        return [];
      }
      
      // Otherwise, filter by the specified category
      const results = await db.select().from(products)
        .where(eq(products.category, category))
        .where(eq(products.status, 'active'));
      console.log(`Retrieved ${results.length} products in category ${category}`);
      return results;
    } catch (error) {
      console.error("Error retrieving products by category:", error);
      throw error;
    }
  }
  
  async getHighlightedProducts(): Promise<Product[]> {
    console.log("Getting highlighted products - returning empty array (Featured section removal)");
    // Return empty array to completely remove Featured Products section
    return [];
  }
  
  async getProductsByProviderId(providerId: string): Promise<Product[]> {
    console.log("Getting products by provider ID:", providerId);
    try {
      const results = await db.select().from(products)
        .where(eq(products.printProviderId, providerId));
      console.log(`Retrieved ${results.length} products with provider ID ${providerId}`);
      return results;
    } catch (error) {
      console.error("Error retrieving products by provider ID:", error);
      throw error;
    }
  }

  async getProduct(id: number): Promise<Product | undefined> {
    console.log("Getting product with ID:", id);
    try {
      const result = await db.select().from(products).where(eq(products.id, id));
      console.log("Product retrieved successfully:", result[0]?.name);
      return result[0];
    } catch (error) {
      console.error("Error retrieving product:", error);
      throw error;
    }
  }

  async createProduct(product: InsertProduct): Promise<Product> {
    console.log("Creating product:", product.name);
    try {
      // Process arrays to ensure correct format
      const imageUrlsArray = Array.isArray(product.imageUrls) ? product.imageUrls : [];
      const designUrlsArray = Array.isArray(product.designUrls) ? product.designUrls : [];
      const mockupUrlsArray = Array.isArray(product.mockupUrls) ? product.mockupUrls : [];
      
      const result = await db.insert(products).values({
        ...product,
        imageUrls: imageUrlsArray,
        designUrls: designUrlsArray,
        mockupUrls: mockupUrlsArray,
        variantData: product.variantData || {},
      }).returning();
      
      console.log("Product created successfully with ID:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error creating product:", error);
      throw error;
    }
  }

  async updateProduct(id: number, data: Partial<Product>): Promise<Product> {
    console.log("Updating product with ID:", id);
    try {
      // First verify the product exists
      const existingProduct = await db.select().from(products).where(eq(products.id, id));
      
      if (!existingProduct.length) {
        throw new Error("Product not found");
      }
      
      // Perform the update
      const [updated] = await db.update(products)
        .set({
          ...data,
          updatedAt: new Date()
        })
        .where(eq(products.id, id))
        .returning();
      
      if (!updated) {
        throw new Error("Failed to update product");
      }
      
      console.log("Product updated successfully:", updated.name);
      return updated;
    } catch (error) {
      console.error("Error updating product:", error);
      throw error;
    }
  }

  async deleteProduct(id: number): Promise<void> {
    console.log("Deleting product with ID:", id);
    try {
      await db.delete(products).where(eq(products.id, id));
      console.log("Product deleted successfully");
    } catch (error) {
      console.error("Error deleting product:", error);
      throw error;
    }
  }

  async deleteAllProducts(): Promise<void> {
    console.log("Deleting all store products");
    try {
      // Use a transaction to ensure data consistency
      await db.transaction(async (tx) => {
        // First, delete any related order items that reference products
        console.log("Deleting order items that reference products");
        await tx.delete(orderItems);
        console.log("Order items deleted successfully");
        
        // Then delete all products
        const result = await tx.delete(products).returning();
        console.log(`Successfully deleted ${result.length} store products`);
      });
      
      console.log("All store products and related data deleted successfully");
    } catch (error) {
      console.error("Error deleting all store products:", error);
      throw error;
    }
  }
  
  // Order operations
  async getOrders(): Promise<Order[]> {
    console.log("Getting all orders");
    try {
      const results = await db.select().from(orders);
      console.log("Orders retrieved successfully");
      return results;
    } catch (error) {
      console.error("Error retrieving orders:", error);
      throw error;
    }
  }

  async getUserOrders(userId: number): Promise<Order[]> {
    console.log("Getting orders for user ID:", userId);
    try {
      const results = await db.select().from(orders).where(eq(orders.userId, userId));
      console.log(`Retrieved ${results.length} orders for user ${userId}`);
      return results;
    } catch (error) {
      console.error("Error retrieving user orders:", error);
      throw error;
    }
  }

  async getOrder(id: number): Promise<Order | undefined> {
    console.log("Getting order with ID:", id);
    try {
      const result = await db.select().from(orders).where(eq(orders.id, id));
      console.log("Order retrieved successfully:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error retrieving order:", error);
      throw error;
    }
  }

  async createOrder(order: InsertOrder): Promise<Order> {
    console.log("Creating order for user:", order.userId);
    try {
      // Format total as string if it's a number
      const formattedOrder = {
        ...order,
        total: typeof order.total === 'number' ? order.total.toString() : order.total,
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      
      console.log("Formatted order data:", formattedOrder);
      const result = await db.insert(orders).values(formattedOrder).returning();
      console.log("Order created successfully with ID:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error creating order:", error);
      throw error;
    }
  }

  async updateOrder(id: number, data: Partial<Order>): Promise<Order> {
    console.log("Updating order with ID:", id);
    try {
      const [updated] = await db.update(orders)
        .set({
          ...data,
          updatedAt: new Date()
        })
        .where(eq(orders.id, id))
        .returning();
      
      console.log("Order updated successfully:", updated?.id);
      return updated;
    } catch (error) {
      console.error("Error updating order:", error);
      throw error;
    }
  }

  async deleteOrder(id: number): Promise<void> {
    console.log("Deleting order with ID:", id);
    try {
      // First delete all related order items
      await db.transaction(async (tx) => {
        await tx.delete(orderItems).where(eq(orderItems.orderId, id));
        await tx.delete(orders).where(eq(orders.id, id));
      });
      console.log("Order and all related items deleted successfully");
    } catch (error) {
      console.error("Error deleting order:", error);
      throw error;
    }
  }
  
  // Alias for getOrder to maintain compatibility with existing code
  async getOrderById(id: number): Promise<Order | undefined> {
    return this.getOrder(id);
  }
  
  // Get all orders for a specific user
  async getOrdersByUserId(userId: number): Promise<Order[]> {
    console.log("Getting orders for user ID:", userId);
    try {
      const results = await db.select().from(orders).where(eq(orders.userId, userId));
      console.log(`Retrieved ${results.length} orders for user ${userId}`);
      return results;
    } catch (error) {
      console.error("Error retrieving user orders:", error);
      throw error;
    }
  }
  
  // Get all orders with specific statuses
  async getOrdersByStatus(statuses: string[]): Promise<Order[]> {
    console.log(`Getting orders with statuses: ${statuses.join(', ')}`);
    try {
      if (!statuses.length) {
        console.log('No statuses provided, returning empty array');
        return [];
      }
      
      // Build OR conditions for each status
      const statusConditions = statuses.map(status => eq(orders.status, status));
      const results = await db.select().from(orders).where(sql`${or(...statusConditions)}`);
      
      console.log(`Retrieved ${results.length} orders with the requested statuses`);
      return results;
    } catch (error) {
      console.error("Error retrieving orders by status:", error);
      throw error;
    }
  }
  
  // Get all orders (admin only)
  async getAllOrders(): Promise<Order[]> {
    console.log("Getting all orders (admin function)");
    try {
      const results = await db.select().from(orders).orderBy(desc(orders.createdAt));
      console.log(`Retrieved ${results.length} total orders`);
      return results;
    } catch (error) {
      console.error("Error retrieving all orders:", error);
      throw error;
    }
  }
  
  // Order item operations
  async getOrderItems(orderId: number): Promise<OrderItem[]> {
    console.log("Getting items for order ID:", orderId);
    try {
      const results = await db.select().from(orderItems).where(eq(orderItems.orderId, orderId));
      console.log(`Retrieved ${results.length} items for order ${orderId}`);
      return results;
    } catch (error) {
      console.error("Error retrieving order items:", error);
      throw error;
    }
  }

  async createOrderItem(orderItem: InsertOrderItem): Promise<OrderItem> {
    console.log("Creating order item for order:", orderItem.orderId);
    try {
      // Ensure price is stored as a string (as expected by the schema)
      const formattedOrderItem = {
        ...orderItem,
        price: orderItem.price.toString()
      };
      
      const result = await db.insert(orderItems).values(formattedOrderItem).returning();
      console.log("Order item created successfully with ID:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error creating order item:", error);
      throw error;
    }
  }

  async deleteOrderItem(id: number): Promise<void> {
    console.log("Deleting order item with ID:", id);
    try {
      await db.delete(orderItems).where(eq(orderItems.id, id));
      console.log("Order item deleted successfully");
    } catch (error) {
      console.error("Error deleting order item:", error);
      throw error;
    }
  }

  // User operations
  async getUser(id: number): Promise<User | undefined> {
    console.log("Storage: Getting user with ID:", id, "Type:", typeof id);
    try {
      // Ensure id is a valid number
      if (typeof id !== 'number' || isNaN(id)) {
        console.error("Storage: Invalid user ID type or NaN:", id);
        throw new Error("Invalid user ID");
      }

      const result = await db.select().from(users).where(eq(users.id, id));
      console.log("Storage: User query result:", result);
      return result[0];
    } catch (error) {
      console.error("Storage: Error retrieving user:", error);
      throw error;
    }
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    console.log("Getting user with username:", username);
    try {
      const result = await db.select().from(users).where(eq(users.username, username));
      console.log("User retrieved successfully:", result[0]);
      return result[0];
    } catch (error) {
      console.error("Error retrieving user:", error);
      throw error;
    }
  }
  
  /**
   * Get a user by username with case-insensitive matching
   * @param username Username to search for
   * @returns User object if found, undefined otherwise
   */
  async getUserByUsernameCaseInsensitive(username: string): Promise<User | undefined> {
    console.log("Getting user with username (case-insensitive):", username);
    try {
      const result = await db.select().from(users).where(
        sql`LOWER(${users.username}) = LOWER(${username})`
      );
      
      if (result.length > 0) {
        console.log("User retrieved successfully with case-insensitive search:", result[0]);
        return result[0];
      } else {
        console.log("No user found with this username (case-insensitive search)");
        return undefined;
      }
    } catch (error) {
      console.error("Error retrieving user with case-insensitive search:", error);
      throw error;
    }
  }
  
  async getUserByEmail(email: string): Promise<User | undefined> {
    console.log("Getting user with email:", email);
    try {
      const result = await db.select().from(users).where(eq(users.email, email));
      console.log("User retrieved successfully:", result[0]);
      return result[0];
    } catch (error) {
      console.error("Error retrieving user by email:", error);
      throw error;
    }
  }
  
  /**
   * Get a user by email with case-insensitive matching
   * @param email Email address to search for
   * @returns User object if found, undefined otherwise
   */
  async getUserByEmailCaseInsensitive(email: string): Promise<User | undefined> {
    console.log("Getting user with email (case-insensitive):", email);
    try {
      const result = await db.select().from(users).where(
        sql`LOWER(${users.email}) = LOWER(${email})`
      );
      
      if (result.length > 0) {
        console.log("User retrieved successfully with case-insensitive search:", result[0]);
        return result[0];
      } else {
        console.log("No user found with this email (case-insensitive search)");
        return undefined;
      }
    } catch (error) {
      console.error("Error retrieving user by email (case-insensitive):", error);
      throw error;
    }
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    console.log("Creating user:", insertUser);
    try {
      const result = await db.insert(users).values({
        ...insertUser,
        isResident: insertUser.isResident ?? false,
        avatarUrl: insertUser.avatarUrl ?? null,
      }).returning();
      console.log("User created successfully:", result[0]);
      return result[0];
    } catch (error) {
      console.error("Error creating user:", error);
      throw error;
    }
  }

  async updateUser(id: number, data: Partial<User>): Promise<User> {
    console.log("Debug: Starting user update in database with:", { id, data });
    try {
      // First verify the user exists
      const existingUser = await db.select().from(users).where(eq(users.id, id));

      if (!existingUser.length) {
        console.error("Debug: User not found for update:", id);
        throw new Error("User not found");
      }

      // Perform the update
      const [updated] = await db.update(users)
        .set({
          ...data,
          updatedAt: new Date()
        })
        .where(eq(users.id, id))
        .returning();

      if (!updated) {
        console.error("Debug: Update operation did not return user");
        throw new Error("Failed to update user");
      }

      // Verify the update by fetching the latest data
      const [verifiedUser] = await db.select()
        .from(users)
        .where(eq(users.id, id));

      console.log("Debug: User updated successfully:", verifiedUser);
      return verifiedUser;
    } catch (error) {
      console.error("Debug: Error updating user in database:", error);
      throw error;
    }
  }
  
  async deleteUser(id: number): Promise<boolean> {
    console.log("Storage: Starting comprehensive user deletion, ID:", id);
    try {
      // First verify the user exists
      const existingUser = await db.select().from(users).where(eq(users.id, id));

      if (!existingUser.length) {
        console.error("Storage: User not found for deletion:", id);
        return false;
      }
      
      console.log(`Storage: Found user for deletion: ${existingUser[0].username} (${id})`);
      
      try {
        // Begin transaction for data integrity
        return await db.transaction(async (tx) => {
          // IMPORTANT: Delete in the proper order to handle foreign key constraints
          
          // Step 1: First forum reactions by this user (no dependencies)
          console.log(`Storage: Deleting forum reactions for user ${id}`);
          await tx.delete(forumReactions).where(eq(forumReactions.userId, id));
          
          // Step 2: Delete forum likes in case this table exists
          try {
            console.log(`Storage: Attempting to delete forum likes for user ${id}`);
            await tx.execute(sql`DELETE FROM forum_likes WHERE user_id = ${id}`);
          } catch (e) {
            console.log("Storage: forum_likes table may not exist, skipping");
          }
          
          // Step 3: Forum comments by this user need to be deleted first
          // Use the correct column name from the DB schema (author_id, not userId)
          console.log(`Storage: Deleting forum comments for user ${id}`);
          await tx.delete(forumComments).where(eq(forumComments.authorId, id));
          
          // Step 4: Now forum posts can be safely deleted
          console.log(`Storage: Deleting forum posts for user ${id}`);
          await tx.delete(forumPosts).where(eq(forumPosts.userId, id));
          
          // Step 5: Event-related data
          console.log(`Storage: Deleting event comments for user ${id}`);
          await tx.delete(eventComments).where(eq(eventComments.userId, id));
          
          console.log(`Storage: Deleting event interactions for user ${id}`);
          await tx.delete(eventInteractions).where(eq(eventInteractions.userId, id));
          
          console.log(`Storage: Deleting events created by user ${id}`);
          await tx.delete(events).where(eq(events.createdBy, id));
          
          // Step 6: Vendor-related data
          console.log(`Storage: Deleting vendor comments for user ${id}`);
          await tx.delete(vendorComments).where(eq(vendorComments.userId, id));
          
          console.log(`Storage: Deleting vendor interactions for user ${id}`);
          await tx.delete(vendorInteractions).where(eq(vendorInteractions.userId, id));
          
          // Step 7: Form submissions
          console.log(`Storage: Deleting form submissions for user ${id}`);
          await tx.delete(formSubmissions).where(eq(formSubmissions.userId, id));
          
          // Step 8: Real estate content
          console.log(`Storage: Deleting listing payments for user ${id}`);
          await tx.delete(listingPayments).where(eq(listingPayments.userId, id));
          
          console.log(`Storage: Deleting real estate listings for user ${id}`);
          await tx.delete(realEstateListings).where(eq(realEstateListings.createdBy, id));
          
          // Step 9: Order information - CRITICAL for preventing deletion failures
          console.log(`Storage: Deleting orders for user ${id}`);
          // Find orders first to potentially clean up related tables
          const userOrders = await tx.select({ id: orders.id })
            .from(orders)
            .where(eq(orders.userId, id));
            
          if (userOrders.length > 0) {
            const orderIds = userOrders.map(o => o.id);
            console.log(`Storage: Found ${orderIds.length} orders to delete`);
            
            // Delete order items first
            console.log(`Storage: Deleting order items`);
            await tx.delete(orderItems)
              .where(inArray(orderItems.orderId, orderIds));
              
            // Now delete the orders
            console.log(`Storage: Deleting orders`);
            await tx.delete(orders).where(eq(orders.userId, id));
          }
          
          // Step 10: Content-related tables that have references to user
          console.log(`Storage: Cleaning up content references`);
          await tx.update(content)
            .set({ updatedBy: null })
            .where(eq(content.updatedBy, id));
            
          // Step 11: Other content models
          console.log(`Storage: Cleaning up page_content references`);
          await tx.update(pageContent)
            .set({ createdBy: null })
            .where(eq(pageContent.createdBy, id));
            
          console.log(`Storage: Cleaning up page_contents references`);
          await tx.update(pageContents)
            .set({ updatedBy: null })
            .where(eq(pageContents.updatedBy, id));
          
          // Step 12: Clean up content versions
          console.log(`Storage: Cleaning up content_versions references`);
          await tx.update(contentVersions)
            .set({ createdBy: null })
            .where(eq(contentVersions.createdBy, id));
          
          // Step 13: Delete products created by this user
          console.log(`Storage: Cleaning up products`);
          await tx.update(products)
            .set({ createdBy: null })
            .where(eq(products.createdBy, id));
            
          // Step 14: Clean up custom forms
          console.log(`Storage: Cleaning up custom forms`);
          await tx.update(customForms)
            .set({ createdBy: null })
            .where(eq(customForms.createdBy, id));
            
          // Step 15: Clean up site settings
          console.log(`Storage: Cleaning up site settings`);
          await tx.update(siteSettings)
            .set({ updatedBy: null })
            .where(eq(siteSettings.updatedBy, id));
          
          // Final step: Delete the user
          console.log(`Storage: Attempting to delete user ${id}`);
          const result = await tx.delete(users).where(eq(users.id, id));
          console.log(`Storage: User deletion successful:`, result);
          
          return true;
        });
      } catch (error) {
        console.error(`Storage: Error during user deletion:`, error);
        
        // Enhanced error logging for identifying the issue
        if (error.code) console.error(`Storage: Error code: ${error.code}`);
        if (error.detail) console.error(`Storage: Error detail: ${error.detail}`);
        if (error.table) console.error(`Storage: Error table: ${error.table}`);
        if (error.constraint) console.error(`Storage: Error constraint: ${error.constraint}`);
        if (error.routine) console.error(`Storage: Error routine: ${error.routine}`);
        if (error.column) console.error(`Storage: Error column: ${error.column}`);
        
        throw error;
      }
    } catch (error) {
      console.error("Storage: Error deleting user from database:", error);
      throw error;
    }
  }

  async getUsers(forceRefresh: boolean = false): Promise<User[]> { 
    console.log("Storage: Getting all users (forceRefresh:", forceRefresh, ")");
    try {
      // Add a specific SQL option to bypass cache if forceRefresh is true
      let query = db.select().from(users);
      
      if (forceRefresh) {
        // For PostgreSQL, adding a comment forces the query not to use cached results
        query = db.$with('force_refresh').select().from(users);
        console.log("Storage: Forcing fresh database query for users");
      }
      
      const results = await query;
      
      // Log some stats about the users
      const unapprovedCount = results.filter(user => user.isApproved === false).length;
      console.log(`Storage: Retrieved ${results.length} users, ${unapprovedCount} unapproved`);
      
      if (unapprovedCount > 0) {
        // Log details about the unapproved users
        const unapprovedUsers = results.filter(user => user.isApproved === false);
        console.log("Storage: Unapproved users:", unapprovedUsers.map(u => ({
          id: u.id,
          username: u.username,
          isApproved: u.isApproved,
          createdAt: u.createdAt
        })));
        
        // Log additional details for debugging purposes
        if (forceRefresh) {
          console.log("Storage: Force refresh found unapproved users:", 
            unapprovedUsers.map(u => u.username).join(', '));
        }
      } else if (forceRefresh) {
        console.log("Storage: Force refresh completed but found no unapproved users");
      }
      
      return results;
    } catch (error) {
      console.error("Error retrieving users:", error);
      throw error;
    }
  }

  // Event operations
  async getEvents(): Promise<Event[]> {
    console.log("Getting all events");
    try {
      const results = await db.select().from(events);
      console.log("Events retrieved successfully:", results);
      return results;
    } catch (error) {
      console.error("Error retrieving events:", error);
      throw error;
    }
  }

  async getEvent(id: number): Promise<Event | undefined> {
    console.log("Getting event with ID:", id);
    try {
      const result = await db.select().from(events).where(eq(events.id, id));
      console.log("Event retrieved successfully:", result[0]);
      return result[0];
    } catch (error) {
      console.error("Error retrieving event:", error);
      throw error;
    }
  }

  async createEvent(insertEvent: InsertEvent): Promise<Event> {
    console.log("DEBUG: Creating event with title:", insertEvent.title);
    console.log("DEBUG: Full event data:", JSON.stringify(insertEvent, null, 2));
    try {
      // Ensure mediaUrls is properly formatted as a text array
      // This is critical since the DB expects text[] but sometimes we get JSON
      let mediaUrlsArray: string[] = [];
      
      if (insertEvent.mediaUrls) {
        if (Array.isArray(insertEvent.mediaUrls)) {
          // Already an array, use it as is
          mediaUrlsArray = insertEvent.mediaUrls;
        } else if (typeof insertEvent.mediaUrls === 'string') {
          try {
            // Maybe it's a JSON string, try to parse it
            const parsed = JSON.parse(insertEvent.mediaUrls);
            if (Array.isArray(parsed)) {
              mediaUrlsArray = parsed;
            } else {
              // If it's just a string, make a single-item array
              mediaUrlsArray = [insertEvent.mediaUrls];
            }
          } catch (e) {
            // If not valid JSON, treat as a single string URL
            mediaUrlsArray = [insertEvent.mediaUrls];
          }
        }
      }
      
      console.log("DEBUG: Processed mediaUrls to array format:", mediaUrlsArray);
      
      // Basic event values
      const eventValues = {
        ...insertEvent,
        description: insertEvent.description || null,
        location: insertEvent.location || null,
        mapLink: insertEvent.mapLink || null,
        hoursOfOperation: insertEvent.hoursOfOperation || null,
        contactInfo: insertEvent.contactInfo || null,
        mediaUrls: mediaUrlsArray,
        createdBy: insertEvent.createdBy || null,
        // Recurring event fields
        isRecurring: insertEvent.isRecurring || false,
        recurrenceFrequency: insertEvent.recurrenceFrequency || null,
        recurrenceEndDate: insertEvent.recurrenceEndDate || null,
        parentEventId: insertEvent.parentEventId || null,
      };

      console.log("DEBUG: Prepared event values:", JSON.stringify(eventValues, null, 2));
      
      // Insert the main event
      console.log("DEBUG: Executing database insert operation");
      const result = await db.insert(events).values(eventValues).returning();
      console.log("DEBUG: Insert operation completed, result:", result);
      
      const createdEvent = result[0];
      console.log("DEBUG: Event created successfully with ID:", createdEvent?.id);

      // If this is a recurring event, create the future instances
      if (createdEvent.isRecurring && createdEvent.recurrenceFrequency && createdEvent.recurrenceEndDate) {
        console.log("Creating recurring event instances...");
        await this.createRecurringEventInstances(createdEvent);
      }

      return createdEvent;
    } catch (error) {
      console.error("Error creating event:", error);
      throw error;
    }
  }
  
  /**
   * Creates recurring event instances based on a parent event
   */
  private async createRecurringEventInstances(parentEvent: Event): Promise<void> {
    try {
      if (!parentEvent.isRecurring || !parentEvent.recurrenceFrequency || !parentEvent.recurrenceEndDate) {
        console.log("Not a valid recurring event, skipping instance creation");
        return;
      }
      
      // Get the dates for all instances based on the frequency
      const instanceDates = this.calculateRecurringDates(
        new Date(parentEvent.startDate),
        new Date(parentEvent.endDate),
        parentEvent.recurrenceFrequency,
        new Date(parentEvent.recurrenceEndDate)
      );
      
      console.log(`Creating ${instanceDates.length} recurring instances`);
      
      // Skip the first date since that's the parent event itself
      const futureDates = instanceDates.slice(1);
      
      // Create instances for all future dates
      for (const { start, end } of futureDates) {
        const eventDuration = new Date(parentEvent.endDate).getTime() - new Date(parentEvent.startDate).getTime();
        
        // Ensure mediaUrls is properly formatted as a text array for child events too
        let childMediaUrls = [];
        if (parentEvent.mediaUrls && Array.isArray(parentEvent.mediaUrls)) {
          childMediaUrls = parentEvent.mediaUrls;
        }
        
        const instanceValues = {
          title: parentEvent.title,
          description: parentEvent.description,
          startDate: start,
          endDate: end,
          location: parentEvent.location,
          mapLink: parentEvent.mapLink,
          hoursOfOperation: parentEvent.hoursOfOperation,
          category: parentEvent.category,
          contactInfo: parentEvent.contactInfo,
          mediaUrls: childMediaUrls,
          createdBy: parentEvent.createdBy,
          // Recurring event specific fields
          isRecurring: false, // Only the parent is marked as recurring
          parentEventId: parentEvent.id, // Link back to the parent
          recurrenceFrequency: null,
          recurrenceEndDate: null,
        };
        
        await db.insert(events).values(instanceValues);
      }
      
      console.log("Successfully created all recurring event instances");
    } catch (error) {
      console.error("Error creating recurring event instances:", error);
      throw error;
    }
  }
  
  /**
   * Calculates the dates for recurring events based on frequency
   * Returns an array of {start, end} date pairs
   */
  private calculateRecurringDates(
    startDate: Date,
    endDate: Date,
    frequency: string,
    recurrenceEndDate: Date
  ): Array<{ start: Date; end: Date }> {
    const result: Array<{ start: Date; end: Date }> = [];
    const eventDuration = endDate.getTime() - startDate.getTime();
    
    // Add the original date
    result.push({
      start: new Date(startDate),
      end: new Date(endDate)
    });
    
    // Function to add days to a date
    const addDays = (date: Date, days: number): Date => {
      const result = new Date(date);
      result.setDate(result.getDate() + days);
      return result;
    };
    
    // Function to add months to a date
    const addMonths = (date: Date, months: number): Date => {
      const result = new Date(date);
      result.setMonth(result.getMonth() + months);
      return result;
    };
    
    // Function to add years to a date
    const addYears = (date: Date, years: number): Date => {
      const result = new Date(date);
      result.setFullYear(result.getFullYear() + years);
      return result;
    };
    
    let currentDate = new Date(startDate);
    
    while (currentDate < recurrenceEndDate) {
      // Calculate next date based on frequency
      switch (frequency) {
        case 'daily':
          currentDate = addDays(currentDate, 1);
          break;
        case 'weekly':
          currentDate = addDays(currentDate, 7);
          break;
        case 'biweekly':
          currentDate = addDays(currentDate, 14);
          break;
        case 'monthly':
          currentDate = addMonths(currentDate, 1);
          break;
        case 'yearly':
          currentDate = addYears(currentDate, 1);
          break;
        default:
          console.warn("Unknown frequency:", frequency);
          return result;
      }
      
      // Stop if we've gone past the end date
      if (currentDate > recurrenceEndDate) {
        break;
      }
      
      // Calculate the end date for this instance
      const instanceEndDate = new Date(currentDate.getTime() + eventDuration);
      
      // Add this date pair to the result
      result.push({
        start: new Date(currentDate),
        end: instanceEndDate
      });
    }
    
    return result;
  }

  async deleteEvent(id: number): Promise<void> {
    console.log("Deleting event with ID:", id);
    try {
      // First delete all related records
      await db.transaction(async (tx) => {
        // Delete event comments
        await tx.delete(eventComments)
          .where(eq(eventComments.eventId, id));

        // Delete event interactions
        await tx.delete(eventInteractions)
          .where(eq(eventInteractions.eventId, id));

        // Finally delete the event itself
        await tx.delete(events)
          .where(eq(events.id, id));
      });

      console.log("Event and all related records deleted successfully");
    } catch (error) {
      console.error("Error deleting event:", error);
      throw new Error("Failed to delete event and its related records");
    }
  }

  /**
   * Delete all future recurring event instances that are linked to a parent event
   */
  async deleteChildEvents(parentEventId: number): Promise<void> {
    console.log(`Deleting all future child events for parent ID ${parentEventId}`);
    try {
      const deletedEvents = await db.delete(events)
        .where(eq(events.parentEventId, parentEventId))
        .returning();
      console.log(`Successfully deleted ${deletedEvents.length} child events`);
    } catch (error) {
      console.error("Error deleting child events:", error);
      throw error;
    }
  }
  
  /**
   * Delete an entire recurring event series (parent event and all child events)
   */
  async deleteEventSeries(eventId: number): Promise<void> {
    console.log(`Deleting entire event series for event ID ${eventId}`);
    try {
      // First get the event to determine if it's a parent or child
      const event = await this.getEvent(eventId);
      if (!event) {
        throw new Error(`Event with ID ${eventId} not found`);
      }
      
      // Determine the parent ID (if this is a child event, use its parentEventId)
      const parentId = event.parentEventId || event.id;
      
      // Start a transaction to ensure all related events are deleted
      await db.transaction(async (tx) => {
        // First delete all child events
        const childDeleteResult = await tx.delete(events)
          .where(eq(events.parentEventId, parentId))
          .returning();
        
        // Then delete the parent event
        const parentDeleteResult = await tx.delete(events)
          .where(eq(events.id, parentId))
          .returning();
          
        console.log(`Successfully deleted parent event and ${childDeleteResult.length} child events`);
      });
    } catch (error) {
      console.error("Error deleting event series:", error);
      throw error;
    }
  }
  
  // Get all events in a recurring series (parent and all children)
  async getRecurringSeries(eventId: number): Promise<Event[]> {
    console.log(`Getting all events in recurring series for event ID ${eventId}`);
    try {
      // First get the current event to determine if it's a parent or child
      const currentEvent = await this.getEvent(eventId);
      if (!currentEvent) {
        throw new Error(`Event with ID ${eventId} not found`);
      }
      
      // If this is a child event, use its parentEventId to get the parent
      const parentId = currentEvent.parentEventId || currentEvent.id;
      
      // Get all events in the series (parent and all children)
      const seriesEvents = await db.select()
        .from(events)
        .where(
          sql`${events.id} = ${parentId} OR ${events.parentEventId} = ${parentId}`
        );
      
      console.log(`Found ${seriesEvents.length} events in the recurring series`);
      return seriesEvents;
    } catch (error) {
      console.error("Error getting recurring series events:", error);
      throw error;
    }
  }

  /**
   * Delete all events and their related records (comments, interactions)
   */
  async deleteAllEvents(): Promise<void> {
    console.log("Deleting all events and related records");
    try {
      await db.transaction(async (tx) => {
        // First delete all related records
        await tx.delete(eventComments);
        await tx.delete(eventInteractions);
        
        // Then delete all events
        const result = await tx.delete(events).returning();
        console.log(`Successfully deleted ${result.length} events`);
      });
      
      console.log("All events and related records deleted successfully");
    } catch (error) {
      console.error("Error deleting all events:", error);
      throw new Error("Failed to delete all events and related records");
    }
  }

  async updateEvent(id: number, data: Partial<Event>, editMode?: 'occurrence' | 'series'): Promise<Event> {
    console.log("Updating event:", { id, data, editMode });
    try {
      // Handle special case when turning off recurring events
      const event = await this.getEvent(id);
      if (!event) {
        throw new Error(`Event with ID ${id} not found`);
      }
      
      if (event.isRecurring && data.isRecurring === false) {
        // Delete all child events if recurring is being disabled
        await this.deleteChildEvents(id);
      }
      
      // Handle recurring events - if editing the series, update all events in the series
      if (event.isRecurring && editMode === 'series') {
        console.log("Updating entire recurring event series");
        
        // Get all events in the series
        const seriesEvents = await this.getRecurringSeries(id);
        console.log(`Found ${seriesEvents.length} events in series to update`);
        
        // For series update, store the results for all events
        const updatedEvents = [];
        
        // Update each event in the series
        for (const seriesEvent of seriesEvents) {
          // For each event in the series, we need to maintain its original date/time
          // but update all other fields
          const eventSpecificData = { ...data };
          
          // Don't change the start/end dates of individual events in the series
          // as they need to maintain their original schedule
          if (seriesEvent.id !== id) {
            delete eventSpecificData.startDate;
            delete eventSpecificData.endDate;
          }
          
          // Update this event in the series
          const updated = await this.updateSingleEvent(seriesEvent.id, eventSpecificData);
          updatedEvents.push(updated);
        }
        
        // Return the event that was specifically requested to be updated
        const updatedCurrentEvent = updatedEvents.find(e => e.id === id);
        if (!updatedCurrentEvent) {
          throw new Error("Failed to update the current event in the series");
        }
        
        return updatedCurrentEvent;
      }
      
      // Handle single occurrence update or non-recurring event
      return await this.updateSingleEvent(id, data);
    } catch (error) {
      console.error("Error updating event:", error);
      throw error;
    }
  }
  
  // Helper method to update a single event (used by updateEvent)
  private async updateSingleEvent(id: number, data: Partial<Event>): Promise<Event> {
    console.log("Updating single event. Event ID:", id);
    
    try {
      // First, get the current event to compare before/after
      const currentEvent = await this.getEvent(id);
      console.log("MEDIA DELETION - Current event media URLs:", currentEvent?.mediaUrls);
      
      // Get database column type to handle storage correctly
      const columnTypeResult = await db.execute(
        sql`SELECT data_type FROM information_schema.columns WHERE table_name = 'events' AND column_name = 'media_urls'`
      );
      
      const dataType = columnTypeResult.rows[0]?.data_type;
      console.log(`MEDIA DELETION - Column 'media_urls' database type: ${dataType}`);
      
      // Handle mediaUrls conversion from JSON to array if needed
      const updatedData = { ...data };
      
      if (updatedData.mediaUrls !== undefined) {
        let mediaUrlsArray: string[] = [];
        
        if (Array.isArray(updatedData.mediaUrls)) {
          // Already an array, use it as is
          mediaUrlsArray = updatedData.mediaUrls;
          console.log("MEDIA DELETION - mediaUrls is already an array:", mediaUrlsArray);
        } else if (typeof updatedData.mediaUrls === 'string') {
          try {
            // Maybe it's a JSON string, try to parse it
            const parsed = JSON.parse(updatedData.mediaUrls);
            if (Array.isArray(parsed)) {
              mediaUrlsArray = parsed;
              console.log("MEDIA DELETION - Parsed JSON mediaUrls into array:", mediaUrlsArray);
            } else {
              // If it's just a string, make a single-item array
              mediaUrlsArray = [updatedData.mediaUrls];
              console.log("MEDIA DELETION - Creating single-item array from string:", mediaUrlsArray);
            }
          } catch (e) {
            // If not valid JSON, treat as a single string URL
            mediaUrlsArray = [updatedData.mediaUrls];
            console.log("MEDIA DELETION - Using string as single URL:", mediaUrlsArray);
          }
        } else if (updatedData.mediaUrls === null) {
          // Handle null case explicitly
          mediaUrlsArray = [];
          console.log("MEDIA DELETION - mediaUrls is null, using empty array");
        }
        
        // Deep duplicate the array to ensure we're not creating reference issues
        mediaUrlsArray = [...mediaUrlsArray];
        
        // Ensure the array is really an array of strings, not objects or nested arrays
        const cleanArray = mediaUrlsArray.filter(url => typeof url === 'string' && url.trim() !== '');
        if (cleanArray.length !== mediaUrlsArray.length) {
          console.log("MEDIA DELETION - Cleaned up mediaUrls array by removing non-string items");
          mediaUrlsArray = cleanArray;
        }
        
        console.log("MEDIA DELETION - Final processed mediaUrls array:", mediaUrlsArray);
        
        // For ARRAY type, we need to use a special approach for drizzle
        if (dataType === 'ARRAY') {
          updatedData.mediaUrls = mediaUrlsArray;
          console.log("MEDIA DELETION - Using native array for ARRAY column type");
        } else {
          updatedData.mediaUrls = mediaUrlsArray;
          console.log("MEDIA DELETION - Using standard array for non-ARRAY column type");
        }
      }
      
      // Convert string dates to Date objects if needed
      if (typeof updatedData.recurrenceEndDate === 'string') {
        updatedData.recurrenceEndDate = new Date(updatedData.recurrenceEndDate);
      }

      // Log the final data before performing the update
      console.log("MEDIA DELETION - Final data for update:", {
        id,
        mediaUrls: updatedData.mediaUrls,
        updatedFields: Object.keys(updatedData)
      });
      
      // Perform the database update operation
      const [updated] = await db.update(events)
        .set({
          ...updatedData,
          updatedAt: new Date()
        })
        .where(eq(events.id, id))
        .returning();

      if (!updated) {
        throw new Error("Failed to update event");
      }

      // Compare before and after to confirm changes were applied
      console.log("MEDIA DELETION - Event update results:");
      console.log("  - Before mediaUrls:", currentEvent?.mediaUrls);
      console.log("  - After mediaUrls:", updated.mediaUrls);
      console.log("  - Was mediaUrls changed:", JSON.stringify(currentEvent?.mediaUrls) !== JSON.stringify(updated.mediaUrls));
      
      console.log("Event updated successfully");
      return updated;
    } catch (error) {
      console.error("Error updating event:", error);
      throw error;
    }
  }

  // Event interaction operations
  async getEventInteractions(eventId: number): Promise<EventInteraction[]> {
    console.log("Getting event interactions for event ID:", eventId);
    try {
      const results = await db.select({
        id: eventInteractions.id,
        eventId: eventInteractions.eventId,
        userId: eventInteractions.userId,
        interactionType: eventInteractions.interactionType,
        createdAt: eventInteractions.createdAt,
        user: {
          id: users.id,
          username: users.username,
          avatarUrl: users.avatarUrl,
          isResident: users.isResident
        }
      })
        .from(eventInteractions)
        .leftJoin(users, eq(eventInteractions.userId, users.id))
        .where(eq(eventInteractions.eventId, eventId));
      console.log("Event interactions retrieved successfully:", results);
      return results.map(result => ({
        ...result,
        user: result.user || null
      }));
    } catch (error) {
      console.error("Error retrieving event interactions:", error);
      throw error;
    }
  }

  async getEventInteraction(eventId: number, userId: number, type: string): Promise<EventInteraction | undefined> {
    console.log("Getting event interaction:", { eventId, userId, type });
    try {
      const result = await db.select()
        .from(eventInteractions)
        .where(
          and(
            eq(eventInteractions.eventId, eventId),
            eq(eventInteractions.userId, userId),
            eq(eventInteractions.interactionType, type)
          )
        );
      console.log("Event interaction retrieved successfully:", result[0]);
      return result[0];
    } catch (error) {
      console.error("Error retrieving event interaction:", error);
      throw error;
    }
  }

  async createEventInteraction(interaction: InsertEventInteraction): Promise<EventInteraction> {
    console.log("Creating event interaction:", interaction);
    try {
      const result = await db.insert(eventInteractions)
        .values(interaction)
        .returning();
      console.log("Event interaction created successfully:", result[0]);
      return result[0];
    } catch (error) {
      console.error("Error creating event interaction:", error);
      throw error;
    }
  }

  async deleteEventInteraction(eventId: number, userId: number, type: string): Promise<void> {
    console.log("Deleting event interaction:", { eventId, userId, type });
    try {
      await db.delete(eventInteractions)
        .where(
          and(
            eq(eventInteractions.eventId, eventId),
            eq(eventInteractions.userId, userId),
            eq(eventInteractions.interactionType, type)
          )
        );
      console.log("Event interaction deleted successfully");
    } catch (error) {
      console.error("Error deleting event interaction:", error);
      throw error;
    }
  }

  // Event comment operations
  async getEventComments(eventId: number): Promise<EventComment[]> {
    console.log("Getting event comments for event ID:", eventId);
    try {
      const results = await db.select({
        id: eventComments.id,
        content: eventComments.content,
        createdAt: eventComments.createdAt,
        updatedAt: eventComments.updatedAt,
        eventId: eventComments.eventId,
        userId: eventComments.userId,
        user: {
          id: users.id,
          username: users.username,
          avatarUrl: users.avatarUrl,
          isResident: users.isResident
        }
      })
        .from(eventComments)
        .leftJoin(users, eq(eventComments.userId, users.id))
        .where(eq(eventComments.eventId, eventId))
        .orderBy(desc(eventComments.createdAt));
      console.log("Event comments retrieved successfully:", results);
      return results.map(result => ({
        ...result,
        user: result.user || null
      }));
    } catch (error) {
      console.error("Error retrieving event comments:", error);
      throw error;
    }
  }

  async createEventComment(comment: InsertEventComment): Promise<EventComment> {
    console.log("Creating event comment:", comment);
    try {
      const result = await db.insert(eventComments)
        .values(comment)
        .returning();
      console.log("Event comment created successfully:", result[0]);
      return result[0];
    } catch (error) {
      console.error("Error creating event comment:", error);
      throw error;
    }
  }

  async deleteEventComment(id: number, userId: number): Promise<void> {
    console.log("Deleting event comment:", { id, userId });
    try {
      // If userId is 0, it means an admin is deleting the comment (admin override)
      // In this case, we don't check the userId and allow deleting any comment
      if (userId === 0) {
        // Admin override - can delete any comment
        await db.delete(eventComments)
          .where(eq(eventComments.id, id));
      } else {
        // Regular user can only delete their own comments
        await db.delete(eventComments)
          .where(
            and(
              eq(eventComments.id, id),
              eq(eventComments.userId, userId)
            )
          );
      }
      console.log("Event comment deleted successfully");
    } catch (error) {
      console.error("Error deleting event comment:", error);
      throw error;
    }
  }

  // Real estate operations
  async getListings(): Promise<RealEstateListing[]> {
    console.log("Getting all real estate listings");
    try {
      // Use a more selective select query to avoid issues with missing columns
      let listings = [];
      
      try {
        console.log("[DEBUG] Attempting to get listings with structured query");
        
        // Try a minimal query first to eliminate potential column-related issues
        const minimalQuery = await db.execute(sql`SELECT id, listing_type, title, created_at FROM real_estate_listings LIMIT 1`);
        console.log("[DEBUG] Minimal query successful, retrieved: ", minimalQuery.rowCount, "rows");
        
        // Now try the full structured query
        listings = await db.select({
          id: realEstateListings.id,
          listingType: realEstateListings.listingType,
          category: realEstateListings.category,
          title: realEstateListings.title,
          price: realEstateListings.price,
          address: realEstateListings.address,
          bedrooms: realEstateListings.bedrooms,
          bathrooms: realEstateListings.bathrooms,
          squareFeet: realEstateListings.squareFeet,
          yearBuilt: realEstateListings.yearBuilt,
          description: realEstateListings.description,
          photos: realEstateListings.photos,
          cashOnly: realEstateListings.cashOnly,
          openHouseDate: realEstateListings.openHouseDate,
          openHouseStartTime: realEstateListings.openHouseStartTime,
          openHouseEndTime: realEstateListings.openHouseEndTime,
          contactInfo: realEstateListings.contactInfo,
          isApproved: realEstateListings.isApproved,
          createdBy: realEstateListings.createdBy,
          createdAt: realEstateListings.createdAt,
          updatedAt: realEstateListings.updatedAt,
        }).from(realEstateListings);
      } catch (dbError) {
        console.error("Error in DB query for listings:", dbError);
        
        // Fall back to a simpler, more robust query that should work regardless of schema changes
        console.log("[DEBUG] Attempting fallback query with * selection due to error:", dbError.message);
        
        try {
          // First check if the table exists at all
          const tableCheck = await db.execute(sql`
            SELECT EXISTS (
              SELECT FROM information_schema.tables 
              WHERE table_schema = 'public' 
              AND table_name = 'real_estate_listings'
            );
          `);
          
          const tableExists = tableCheck.rows[0]?.exists === true;
          console.log("[DEBUG] real_estate_listings table exists:", tableExists);
          
          if (!tableExists) {
            throw new Error("real_estate_listings table does not exist");
          }
          
          // If table exists, try to get all rows
          const rawResults = await db.execute(sql`SELECT * FROM real_estate_listings`);
          console.log("[DEBUG] Raw query successful, retrieved:", rawResults.rowCount, "rows");
          
          // Check the structure of the first row for debugging
          if (rawResults.rows.length > 0) {
            const firstRow = rawResults.rows[0];
            console.log("[DEBUG] First row keys:", Object.keys(firstRow));
            console.log("[DEBUG] First row has photos:", firstRow.hasOwnProperty('photos'));
            console.log("[DEBUG] First row photos type:", firstRow.photos ? typeof firstRow.photos : 'undefined');
          }
          
          // Process the raw results into properly structured objects
          listings = rawResults.rows.map(row => {
            try {
              // Convert photos from string to array if needed
              let photos = row.photos;
              if (typeof photos === 'string') {
                try {
                  photos = JSON.parse(photos);
                } catch (parseErr) {
                  photos = [];
                }
              }
              
              // Process contact_info
              let contactInfo = row.contact_info;
              if (typeof contactInfo === 'string') {
                try {
                  contactInfo = JSON.parse(contactInfo);
                } catch (parseErr) {
                  contactInfo = {};
                }
              }
              
              // Build a standardized object
              return {
                id: row.id,
                listingType: row.listing_type,
                category: row.category,
                title: row.title,
                price: row.price,
                address: row.address,
                bedrooms: row.bedrooms,
                bathrooms: row.bathrooms,
                squareFeet: row.square_feet,
                yearBuilt: row.year_built,
                description: row.description,
                photos: photos || [],
                cashOnly: row.cash_only,
                openHouseDate: row.open_house_date,
                openHouseStartTime: row.open_house_start_time,
                openHouseEndTime: row.open_house_end_time,
                contactInfo: contactInfo || {},
                isApproved: row.is_approved,
                createdBy: row.created_by,
                createdAt: row.created_at,
                updatedAt: row.updated_at,
              };
            } catch (rowErr) {
              console.error("Error processing listing row:", rowErr);
              // Return a minimal valid object
              return {
                id: row.id || 0,
                listingType: row.listing_type || '',
                title: row.title || '',
                contactInfo: {},
                photos: [],
              };
            }
          });
        } catch (fallbackError) {
          console.error("[DEBUG] Error in fallback query execution:", fallbackError);
          // Return an empty array if even the fallback query fails
          listings = [];
        }
      }
      
      console.log("Listings retrieved successfully:", listings ? listings.length : 0);
      
      // Add default values for missing fields to ensure compatibility with the schema
      return listings.map(listing => {
        try {
          return {
            ...listing,
            // Add missing fields with default values
            expirationDate: listing.expirationDate || null,
            isSubscription: listing.isSubscription || false,
            subscriptionId: listing.subscriptionId || null,
            // Ensure photos is always an array
            photos: Array.isArray(listing.photos) ? listing.photos : [],
          };
        } catch (mappingError) {
          console.error("Error mapping listing:", mappingError);
          // Return a minimal valid object
          return {
            id: listing.id || 0,
            listingType: listing.listingType || '',
            title: listing.title || '',
            contactInfo: {},
            photos: [],
            expirationDate: null,
            isSubscription: false,
            subscriptionId: null,
          };
        }
      });
    } catch (error) {
      console.error("Error retrieving listings:", error);
      // Return empty array instead of throwing to avoid breaking the API
      return [];
    }
  }

  async getListingsByUser(userId: number): Promise<RealEstateListing[]> {
    console.log("Getting real estate listings for user:", userId);
    try {
      // Use the same selective query approach to avoid issues with missing columns
      let listings;
      try {
        listings = await db.select({
          id: realEstateListings.id,
          listingType: realEstateListings.listingType,
          category: realEstateListings.category,
          title: realEstateListings.title,
          price: realEstateListings.price,
          address: realEstateListings.address,
          bedrooms: realEstateListings.bedrooms,
          bathrooms: realEstateListings.bathrooms,
          squareFeet: realEstateListings.squareFeet,
          yearBuilt: realEstateListings.yearBuilt,
          description: realEstateListings.description,
          photos: realEstateListings.photos,
          cashOnly: realEstateListings.cashOnly,
          openHouseDate: realEstateListings.openHouseDate,
          openHouseStartTime: realEstateListings.openHouseStartTime,
          openHouseEndTime: realEstateListings.openHouseEndTime,
          contactInfo: realEstateListings.contactInfo,
          isApproved: realEstateListings.isApproved,
          createdBy: realEstateListings.createdBy,
          createdAt: realEstateListings.createdAt,
          updatedAt: realEstateListings.updatedAt,
        })
          .from(realEstateListings)
          .where(eq(realEstateListings.createdBy, userId));
      } catch (dbError) {
        console.error("Error in DB query for user listings:", dbError);
        
        // Fall back to a simpler, more robust query that should work regardless of schema changes
        console.log("Attempting fallback query with * selection for user listings");
        const rawResults = await db.execute(
          sql`SELECT * FROM real_estate_listings WHERE created_by = ${userId}`
        );
        
        // Process the raw results into properly structured objects
        listings = rawResults.rows.map(row => {
          try {
            // Convert photos from string to array if needed
            let photos = row.photos;
            if (typeof photos === 'string') {
              try {
                photos = JSON.parse(photos);
              } catch (parseErr) {
                photos = [];
              }
            }
            
            // Process contact_info
            let contactInfo = row.contact_info;
            if (typeof contactInfo === 'string') {
              try {
                contactInfo = JSON.parse(contactInfo);
              } catch (parseErr) {
                contactInfo = {};
              }
            }
            
            // Build a standardized object
            return {
              id: row.id,
              listingType: row.listing_type,
              category: row.category,
              title: row.title,
              price: row.price,
              address: row.address,
              bedrooms: row.bedrooms,
              bathrooms: row.bathrooms,
              squareFeet: row.square_feet,
              yearBuilt: row.year_built,
              description: row.description,
              photos: photos || [],
              cashOnly: row.cash_only,
              openHouseDate: row.open_house_date,
              openHouseStartTime: row.open_house_start_time,
              openHouseEndTime: row.open_house_end_time,
              contactInfo: contactInfo || {},
              isApproved: row.is_approved,
              createdBy: row.created_by,
              createdAt: row.created_at,
              updatedAt: row.updated_at,
            };
          } catch (rowErr) {
            console.error("Error processing user listing row:", rowErr);
            // Return a minimal valid object
            return {
              id: row.id || 0,
              listingType: row.listing_type || '',
              title: row.title || '',
              contactInfo: {},
              photos: [],
            };
          }
        });
      }
      
      console.log(`Retrieved ${listings.length} listings for user ${userId}`);
      
      // Add default values for missing fields to ensure compatibility with the schema
      return listings.map(listing => {
        try {
          return {
            ...listing,
            // Add missing fields with default values
            expirationDate: listing.expirationDate || null,
            isSubscription: listing.isSubscription || false,
            subscriptionId: listing.subscriptionId || null,
            // Ensure photos is always an array
            photos: Array.isArray(listing.photos) ? listing.photos : [],
          };
        } catch (mappingError) {
          console.error("Error mapping user listing:", mappingError);
          // Return a minimal valid object
          return {
            id: listing.id || 0,
            listingType: listing.listingType || '',
            title: listing.title || '',
            contactInfo: {},
            photos: [],
            expirationDate: null,
            isSubscription: false,
            subscriptionId: null,
          };
        }
      });
    } catch (error) {
      console.error("Error retrieving user listings:", error);
      // Return empty array instead of throwing to avoid breaking the API
      return [];
    }
  }
  
  async getListingsBySubscriptionId(subscriptionId: string): Promise<RealEstateListing[]> {
    console.log("Getting listings with subscription ID:", subscriptionId);
    try {
      // For now, return an empty array if this method is called
      // since the schema hasn't been updated yet
      console.log(`Retrieved 0 listings with subscription ID ${subscriptionId} (columns not yet in database)`);
      return [];
      
      /* 
      // This code will work after the database schema is updated
      const listings = await db.select({
        id: realEstateListings.id,
        listingType: realEstateListings.listingType,
        category: realEstateListings.category,
        title: realEstateListings.title,
        price: realEstateListings.price,
        address: realEstateListings.address,
        bedrooms: realEstateListings.bedrooms,
        bathrooms: realEstateListings.bathrooms,
        squareFeet: realEstateListings.squareFeet,
        yearBuilt: realEstateListings.yearBuilt,
        description: realEstateListings.description,
        photos: realEstateListings.photos,
        cashOnly: realEstateListings.cashOnly,
        openHouseDate: realEstateListings.openHouseDate,
        openHouseStartTime: realEstateListings.openHouseStartTime,
        openHouseEndTime: realEstateListings.openHouseEndTime,
        contactInfo: realEstateListings.contactInfo,
        isApproved: realEstateListings.isApproved,
        createdBy: realEstateListings.createdBy,
        createdAt: realEstateListings.createdAt,
        updatedAt: realEstateListings.updatedAt,
      })
        .from(realEstateListings)
        .where(
          and(
            eq(realEstateListings.isSubscription, true),
            eq(realEstateListings.subscriptionId, subscriptionId)
          )
        );
        
      console.log(`Retrieved ${listings.length} listings with subscription ID ${subscriptionId}`);
      
      // Add default values for missing fields
      return listings.map(listing => ({
        ...listing,
        // Add missing fields with default values
        expirationDate: null,
        isSubscription: false,
        subscriptionId: null,
      }));
      */
    } catch (error) {
      console.error("Error retrieving listings by subscription ID:", error);
      throw error;
    }
  }
  
  async getListingPaymentsBySubscription(subscriptionId: string): Promise<ListingPayment[]> {
    console.log("Getting payments for subscription:", subscriptionId);
    try {
      const payments = await db.select()
        .from(listingPayments)
        .where(eq(listingPayments.subscriptionId, subscriptionId))
        .orderBy(desc(listingPayments.createdAt));
      console.log(`Retrieved ${payments.length} payments for subscription ${subscriptionId}`);
      return payments;
    } catch (error) {
      console.error("Error retrieving subscription payments:", error);
      throw error;
    }
  }

  async getListing(id: number): Promise<RealEstateListing | undefined> {
    console.log("[DEBUG: getListing] Getting listing with ID:", id);
    try {
      // Try a minimal query first to confirm the listing exists
      try {
        console.log("[DEBUG: getListing] Attempting minimal query to check listing existence");
        const checkQuery = await db.execute(sql`SELECT id FROM real_estate_listings WHERE id = ${id} LIMIT 1`);
        
        if (checkQuery.rowCount === 0) {
          console.log(`[DEBUG: getListing] No listing found with ID: ${id}`);
          return undefined;
        }
        
        console.log(`[DEBUG: getListing] Listing with ID: ${id} exists, proceeding with full query`);
      } catch (checkError) {
        console.error("[DEBUG: getListing] Error checking listing existence:", checkError);
        // Continue with the main query even if the check fails
      }
      
      let listing;
      
      try {
        console.log(`[DEBUG: getListing] Attempting structured query for listing ID: ${id}`);
        // Use selective query to avoid missing column issues
        const result = await db.select({
          id: realEstateListings.id,
          listingType: realEstateListings.listingType,
          category: realEstateListings.category,
          title: realEstateListings.title,
          price: realEstateListings.price,
          address: realEstateListings.address,
          bedrooms: realEstateListings.bedrooms,
          bathrooms: realEstateListings.bathrooms,
          squareFeet: realEstateListings.squareFeet,
          yearBuilt: realEstateListings.yearBuilt,
          description: realEstateListings.description,
          photos: realEstateListings.photos,
          cashOnly: realEstateListings.cashOnly,
          openHouseDate: realEstateListings.openHouseDate,
          openHouseStartTime: realEstateListings.openHouseStartTime,
          openHouseEndTime: realEstateListings.openHouseEndTime,
          contactInfo: realEstateListings.contactInfo,
          isApproved: realEstateListings.isApproved,
          createdBy: realEstateListings.createdBy,
          createdAt: realEstateListings.createdAt,
          updatedAt: realEstateListings.updatedAt,
          expirationDate: realEstateListings.expirationDate,
          isSubscription: realEstateListings.isSubscription,
          subscriptionId: realEstateListings.subscriptionId,
          status: realEstateListings.status,
        })
          .from(realEstateListings)
          .where(eq(realEstateListings.id, id));
        
        if (result.length === 0) {
          console.log(`[DEBUG: getListing] No listing found in structured query for ID: ${id}`);
          return undefined;
        }
        
        // Add default values for missing columns
        listing = {
          ...result[0],
          // Add missing fields with default values
          expirationDate: null,
          isSubscription: false,
          subscriptionId: null,
        };
        
        console.log(`[DEBUG: getListing] Structured query successful for ID: ${id}`);
      } catch (dbError) {
        console.error("[DEBUG: getListing] Error in structured query:", dbError);
        
        // Fall back to a simpler, more robust query that should work regardless of schema changes
        console.log(`[DEBUG: getListing] Attempting fallback raw query for ID: ${id}`);
        try {
          const rawResult = await db.execute(sql`SELECT * FROM real_estate_listings WHERE id = ${id} LIMIT 1`);
          
          if (rawResult.rowCount === 0) {
            console.log(`[DEBUG: getListing] No listing found in fallback query for ID: ${id}`);
            return undefined;
          }
          
          const row = rawResult.rows[0];
          
          // Convert photos from string to array if needed
          let photos = row.photos;
          if (typeof photos === 'string') {
            try {
              photos = JSON.parse(photos);
            } catch (parseErr) {
              console.error("[DEBUG: getListing] Error parsing photos JSON:", parseErr);
              photos = [];
            }
          }
          
          // Process contact_info
          let contactInfo = row.contact_info;
          if (typeof contactInfo === 'string') {
            try {
              contactInfo = JSON.parse(contactInfo);
            } catch (parseErr) {
              console.error("[DEBUG: getListing] Error parsing contactInfo JSON:", parseErr);
              contactInfo = {};
            }
          }
          
          // Build a standardized object
          listing = {
            id: row.id,
            listingType: row.listing_type,
            category: row.category,
            title: row.title,
            price: row.price,
            address: row.address,
            bedrooms: row.bedrooms,
            bathrooms: row.bathrooms,
            squareFeet: row.square_feet,
            yearBuilt: row.year_built,
            description: row.description,
            photos: photos || [],
            cashOnly: row.cash_only,
            openHouseDate: row.open_house_date,
            openHouseStartTime: row.open_house_start_time,
            openHouseEndTime: row.open_house_end_time,
            contactInfo: contactInfo || {},
            isApproved: row.is_approved,
            createdBy: row.created_by,
            createdAt: row.created_at,
            updatedAt: row.updated_at,
            expirationDate: row.expiration_date || null,
            isSubscription: row.is_subscription || false,
            subscriptionId: row.subscription_id || null,
            status: row.status || "ACTIVE", // Default to ACTIVE if not present
          };
          
          console.log(`[DEBUG: getListing] Fallback query successful for ID: ${id}`);
        } catch (fallbackError) {
          console.error("[DEBUG: getListing] Fatal error in fallback query:", fallbackError);
          throw fallbackError;
        }
      }
      
      console.log(`[DEBUG: getListing] Listing retrieved successfully:`, {
        id: listing.id,
        title: listing.title,
        photoCount: listing.photos ? listing.photos.length : 0
      });
      
      return listing;
    } catch (error) {
      console.error("[DEBUG: getListing] Error retrieving listing:", error);
      throw error;
    }
  }

  async createListing(insertListing: InsertListing): Promise<RealEstateListing> {
    console.log("Creating listing, preparing data for insert");
    try {
      // Use all data now that the columns exist in the database
      const finalData = {
        ...insertListing,
        description: insertListing.description || null,
        photos: insertListing.photos || [],
        createdBy: insertListing.createdBy || null,
        // Default status to DRAFT if not provided
        status: insertListing.status || "DRAFT",
        expirationDate: insertListing.expirationDate || null,
        isSubscription: insertListing.isSubscription || false,
        subscriptionId: insertListing.subscriptionId || null,
        createdAt: insertListing.createdAt || new Date(),
        updatedAt: insertListing.updatedAt || new Date()
      };
      
      console.log("Inserting listing with complete data");
      const result = await db.insert(realEstateListings).values(finalData).returning();
      console.log("Listing created successfully:", result[0]);
      return result[0];
    } catch (error) {
      console.error("Error creating listing:", error);
      // Log more details about the error
      if (error instanceof Error) {
        console.error("Error message:", error.message);
        console.error("Error stack:", error.stack);
      }
      // For PostgreSQL errors
      if (error && typeof error === 'object' && 'code' in error) {
        console.error("Database error code:", (error as any).code);
        console.error("Database error detail:", (error as any).detail);
        console.error("Database error constraint:", (error as any).constraint);
      }
      throw error;
    }
  }

  // Method removed, using the improved version below instead
          subscriptionId: subscriptionId,
          isSubscription: !!subscriptionId,
          updatedAt: new Date()
        })
        .where(eq(realEstateListings.id, id))
        .returning();
      
      if (!published) {
        throw new Error(`Failed to publish listing with ID ${id}`);
      }
      
      console.log("Listing published successfully:", published);
      return published;
    } catch (error) {
      console.error("Error publishing listing:", error);
      throw error;
    }
  }
  
  async updateListing(id: number, data: Partial<RealEstateListing>): Promise<RealEstateListing> {
    console.log("Updating listing:", { id, data });
    try {
      const [updated] = await db.update(realEstateListings)
        .set({
          ...data,
          updatedAt: new Date()
        })
        .where(eq(realEstateListings.id, id))
        .returning();

      if (!updated) {
        throw new Error("Failed to update listing");
      }

      console.log("Listing updated successfully:", updated);
      return updated;
    } catch (error) {
      console.error("Error updating listing:", error);
      throw error;
    }
  }
  
  /**
   * Publish a listing, changing its status to ACTIVE and setting expiration date
   * @param id Listing ID
   * @param duration Duration of the listing (3_day, 7_day, 30_day)
   * @param subscriptionId Optional subscription ID if the listing is tied to a subscription
   * @returns Updated listing
   */
  async publishListing(id: number, duration: string, subscriptionId?: string): Promise<RealEstateListing> {
    console.log(`Publishing listing ${id} with duration ${duration}`);
    try {
      // Calculate expiration date based on the duration
      const expirationDate = new Date();
      if (duration === '3_day' || duration === '3' || duration === '3day') {
        expirationDate.setDate(expirationDate.getDate() + 3);
      } else if (duration === '7_day' || duration === '7' || duration === '7day') {
        expirationDate.setDate(expirationDate.getDate() + 7);
      } else if (duration === '30_day' || duration === '30' || duration === '30day') {
        expirationDate.setDate(expirationDate.getDate() + 30);
      } else {
        // Default to 30 days if duration is not recognized
        expirationDate.setDate(expirationDate.getDate() + 30);
      }
      
      // Normalize the duration for storage
      let normalizedDuration = duration;
      if (duration === '3' || duration === '3day') normalizedDuration = '3_day';
      if (duration === '7' || duration === '7day') normalizedDuration = '7_day';
      if (duration === '30' || duration === '30day') normalizedDuration = '30_day';
      
      // Update the listing with new status and expiration
      const [updated] = await db.update(realEstateListings)
        .set({
          status: "ACTIVE",
          expirationDate,
          listingDuration: normalizedDuration,
          isSubscription: !!subscriptionId,
          subscriptionId: subscriptionId || null,
          updatedAt: new Date()
        })
        .where(eq(realEstateListings.id, id))
        .returning();

      if (!updated) {
        throw new Error("Failed to publish listing");
      }

      console.log("Listing published successfully:", updated);
      return updated;
    } catch (error) {
      console.error("Error publishing listing:", error);
      throw error;
    }
  }
  
  /**
   * Expire a listing by changing its status to EXPIRED
   * @param id Listing ID
   * @returns Updated listing
   */
  async expireListing(id: number): Promise<RealEstateListing> {
    console.log(`Expiring listing ${id}`);
    try {
      const [updated] = await db.update(realEstateListings)
        .set({
          status: "EXPIRED",
          updatedAt: new Date()
        })
        .where(eq(realEstateListings.id, id))
        .returning();

      if (!updated) {
        throw new Error("Failed to expire listing");
      }

      console.log("Listing expired successfully:", updated);
      return updated;
    } catch (error) {
      console.error("Error expiring listing:", error);
      throw error;
    }
  }

  async deleteListing(id: number): Promise<void> {
    console.log("Deleting listing with ID:", id);
    try {
      await db.delete(realEstateListings)
        .where(eq(realEstateListings.id, id));
      console.log("Listing deleted successfully");
    } catch (error) {
      console.error("Error deleting listing:", error);
      throw error;
    }
  }
  
  async deleteAllListings(): Promise<void> {
    console.log("Deleting all listings and related records");
    try {
      // Use a transaction to ensure data consistency
      await db.transaction(async (tx) => {
        // First, get all listings to log the count
        const allListings = await tx.select({ id: realEstateListings.id }).from(realEstateListings);
        console.log(`Found ${allListings.length} listings to delete`);
        
        // Delete all related payment records first
        const deletedPayments = await tx.delete(listingPayments).returning({ id: listingPayments.id });
        console.log(`Deleted ${deletedPayments.length} listing payment records`);
        
        // Then delete all listings
        const deletedListings = await tx.delete(realEstateListings).returning({ id: realEstateListings.id });
        console.log(`Successfully deleted ${deletedListings.length} listings`);
      });
      
      console.log("All listings and related records deleted successfully");
    } catch (error) {
      console.error("Error deleting all listings:", error);
      throw new Error("Failed to delete all listings and related records");
    }
  }
  
  async getExpiredListings(referenceDate?: Date): Promise<RealEstateListing[]> {
    console.log("Getting expired real estate listings");
    try {
      const currentDate = referenceDate || new Date();
      console.log(`Using reference date: ${currentDate.toISOString()}`);
      
      // First check if the expiration_date column exists in the database
      let hasExpirationColumn = false;
      try {
        // Try a query that requires the column to exist
        await db.execute(sql`SELECT expiration_date FROM real_estate_listings LIMIT 1`);
        hasExpirationColumn = true;
        console.log("expiration_date column found in database");
      } catch (error) {
        console.log("expiration_date column does not exist in database yet");
        return []; // Return empty array if column doesn't exist
      }
      
      // Check if listing_duration column exists in the database
      let hasListingDurationColumn = false;
      try {
        // Try a query that requires the column to exist
        await db.execute(sql`SELECT listing_duration FROM real_estate_listings LIMIT 1`);
        hasListingDurationColumn = true;
        console.log("listing_duration column found in database");
      } catch (error) {
        console.log("listing_duration column does not exist in database yet");
      }
      
      if (hasExpirationColumn) {
        // Column exists, we can proceed with the query
        const listings = await db.select()
          .from(realEstateListings)
          .where(
            and(
              // Only get listings with an expiration date
              sql`${realEstateListings.expirationDate} IS NOT NULL`,
              // Only get listings where the expiration date is in the past
              sql`${realEstateListings.expirationDate} < ${currentDate}`,
              // Make sure we only process approved listings
              eq(realEstateListings.isApproved, true)
            )
          );
          
        console.log(`Found ${listings.length} expired listings`);
        return listings;
      } else {
        console.log(`Found 0 expired listings (expiration_date column not yet in database)`);
        return [];
      }
    } catch (error) {
      console.error("Error retrieving expired listings:", error);
      return []; // Return empty array on error for graceful handling
    }
  }
  
  async getExpiringListings(daysUntilExpiration: number): Promise<RealEstateListing[]> {
    console.log(`Getting listings expiring within ${daysUntilExpiration} days`);
    try {
      const currentDate = new Date();
      const futureDate = new Date();
      futureDate.setDate(currentDate.getDate() + daysUntilExpiration);
      
      // First check if the expiration_date column exists in the database
      let hasExpirationColumn = false;
      try {
        // Try a query that requires the column to exist
        await db.execute(sql`SELECT expiration_date FROM real_estate_listings LIMIT 1`);
        hasExpirationColumn = true;
        console.log("expiration_date column found in database");
      } catch (error) {
        console.log("expiration_date column does not exist in database yet");
        return []; // Return empty array if column doesn't exist
      }
      
      if (hasExpirationColumn) {
        // Column exists, we can proceed with the query
        const listings = await db.select()
          .from(realEstateListings)
          .where(
            and(
              // Only get listings with an expiration date
              sql`${realEstateListings.expirationDate} IS NOT NULL`,
              // Only get listings where the expiration date is between now and the future date
              sql`${realEstateListings.expirationDate} >= ${currentDate}`,
              sql`${realEstateListings.expirationDate} <= ${futureDate}`,
              // Only include approved listings
              eq(realEstateListings.isApproved, true)
            )
          );
          
        console.log(`Found ${listings.length} listings expiring within ${daysUntilExpiration} days`);
        return listings;
      } else {
        console.log(`Found 0 listings expiring within ${daysUntilExpiration} days (expiration_date column not yet in database)`);
        return [];
      }
    } catch (error) {
      console.error("Error retrieving expiring listings:", error);
      return []; // Return empty array on error for graceful handling
    }
  }
  
  async getListingsWithoutExpiration(): Promise<RealEstateListing[]> {
    console.log("Getting listings without expiration dates");
    try {
      // First check if the expiration_date column exists in the database
      let hasExpirationColumn = false;
      try {
        // Try a query that requires the column to exist
        await db.execute(sql`SELECT expiration_date FROM real_estate_listings LIMIT 1`);
        hasExpirationColumn = true;
        console.log("expiration_date column found in database");
      } catch (error) {
        console.log("expiration_date column does not exist in database yet");
        return []; // Return empty array if column doesn't exist
      }
      
      if (hasExpirationColumn) {
        // Column exists, we can proceed with the query
        const listings = await db.select()
          .from(realEstateListings)
          .where(
            or(
              isNull(realEstateListings.expirationDate),
              eq(realEstateListings.expirationDate, sql`CAST('1970-01-01' AS DATE)`)
            )
          );
        
        console.log(`Found ${listings.length} listings without expiration dates`);
        return listings;
      } else {
        console.log(`Found 0 listings without expiration dates (expiration_date column not yet in database)`);
        return [];
      }
    } catch (error) {
      console.error("Error retrieving listings without expiration:", error);
      return []; // Return empty array on error for graceful handling
    }
  }
  
  async getUserListingsWithSubscriptions(userId: number): Promise<RealEstateListing[]> {
    console.log(`Getting subscription listings for user ${userId}`);
    try {
      // First check if the subscription columns exist in the database
      let hasSubscriptionColumns = false;
      try {
        // Try a query that requires the columns to exist
        await db.execute(sql`SELECT is_subscription, subscription_id FROM real_estate_listings LIMIT 1`);
        hasSubscriptionColumns = true;
        console.log("subscription columns found in database");
      } catch (error) {
        console.log("subscription columns do not exist in database yet");
        return []; // Return empty array if columns don't exist
      }
      
      if (hasSubscriptionColumns) {
        // Columns exist, we can proceed with the query
        const listings = await db.select()
          .from(realEstateListings)
          .where(
            and(
              eq(realEstateListings.createdBy, userId),
              eq(realEstateListings.isSubscription, true),
              sql`${realEstateListings.subscriptionId} IS NOT NULL`
            )
          );
          
        console.log(`Found ${listings.length} subscription listings for user ${userId}`);
        return listings;
      } else {
        console.log(`Found 0 subscription listings for user ${userId} (columns not yet in database)`);
        return [];
      }
    } catch (error) {
      console.error("Error retrieving user subscription listings:", error);
      return []; // Return empty array on error for graceful handling
    }
  }
  
  // Listing payment operations
  async getListingPayment(id: number): Promise<ListingPayment | undefined> {
    console.log("Getting listing payment with ID:", id);
    try {
      const result = await db.select().from(listingPayments).where(eq(listingPayments.id, id));
      console.log("Payment retrieved successfully:", result[0]);
      return result[0];
    } catch (error) {
      console.error("Error retrieving payment:", error);
      throw error;
    }
  }
  
  async getListingPaymentsByListing(listingId: number): Promise<ListingPayment[]> {
    console.log("Getting payments for listing with ID:", listingId);
    try {
      const payments = await db.select()
        .from(listingPayments)
        .where(eq(listingPayments.listingId, listingId));
      console.log(`Found ${payments.length} payments for listing ${listingId}`);
      return payments;
    } catch (error) {
      console.error("Error retrieving listing payments:", error);
      throw error;
    }
  }

  async getListingPaymentByIntent(paymentIntentId: string): Promise<ListingPayment | undefined> {
    console.log("Getting listing payment with intent ID:", paymentIntentId);
    try {
      const result = await db.select().from(listingPayments).where(eq(listingPayments.paymentIntentId, paymentIntentId));
      console.log("Payment retrieved successfully:", result[0]);
      return result[0];
    } catch (error) {
      console.error("Error retrieving payment by intent:", error);
      throw error;
    }
  }

  async createListingPayment(insertPayment: InsertListingPayment): Promise<ListingPayment> {
    console.log("Creating listing payment:", insertPayment);
    try {
      const result = await db.insert(listingPayments).values({
        ...insertPayment,
        updatedAt: new Date()
      }).returning();
      console.log("Payment created successfully:", result[0]);
      return result[0];
    } catch (error) {
      console.error("Error creating payment:", error);
      throw error;
    }
  }

  async updateListingPayment(id: number, data: Partial<ListingPayment>): Promise<ListingPayment> {
    console.log("Updating listing payment:", id, data);
    try {
      const [updated] = await db.update(listingPayments)
        .set({
          ...data,
          updatedAt: new Date()
        })
        .where(eq(listingPayments.id, id))
        .returning();
      console.log("Payment updated successfully:", updated);
      return updated;
    } catch (error) {
      console.error("Error updating payment:", error);
      throw error;
    }
  }
  // Page content operations
  async getPageContent(slug: string, includeHidden: boolean = false): Promise<PageContent | undefined> {
    console.log(`Storage: Looking for page content with slug "${slug}" (includeHidden: ${includeHidden})`);
    
    // Debug for banner-slides special case
    if (slug === 'banner-slides') {
      console.log(`🎯 Exact "banner-slides" slug requested - NOT a vendor page`);
    }
    
    // Special handling for vendor pages to prevent "banner-slides" from matching
    if (slug.startsWith('vendors-')) {
      console.log(`🔍 Vendor page detected - EXPLICIT handling for: "${slug}"`);
      
      // First try: Get the vendor page by its exact slug 
      // This should always be preferred over matching banner-slides
      let query = db.select()
        .from(pageContents)
        .where(eq(pageContents.slug, slug));
      
      // Only apply the hidden filter if we're not including hidden content
      if (!includeHidden) {
        query = query.where(eq(pageContents.isHidden, false));
      }
      
      const vendorPageResult = await query
        .orderBy(desc(pageContents.updatedAt), desc(pageContents.id))
        .limit(1);
      
      // Debug: Log what we found and what we're returning
      console.log(`Vendor query results: Found ${vendorPageResult.length} pages matching slug "${slug}"`);
      
      if (vendorPageResult.length > 0) {
        const vendorPage = vendorPageResult[0];
        console.log(`✅ Returning vendor page with ID ${vendorPage.id} and title "${vendorPage.title}"`);
        return vendorPage;
      } else {
        console.log(`❌ No vendor page found with slug "${slug}" - continuing with normal search`);
      }
    }
    
    // Standard path for all other content types
    let query = db.select()
      .from(pageContents)
      .where(eq(pageContents.slug, slug));
    
    // If this is a vendor page and we're not including hidden content, add the filter
    if (slug.startsWith('vendors-') && !includeHidden) {
      query = query.where(eq(pageContents.isHidden, false));
    }
    
    const result = await query
      .orderBy(desc(pageContents.updatedAt), desc(pageContents.id))
      .limit(1);
    
    console.log(`Storage: Found ${result.length} results for slug "${slug}"`);
    if (result.length > 0) {
      console.log(`Storage: Returning content with ID ${result[0].id}, title "${result[0].title}"`);
    }
    
    return result[0];
  }
  
  async getAllPageContents(includeHidden: boolean = false): Promise<PageContent[]> {
    console.log(`Storage: Getting all page contents (includeHidden: ${includeHidden})`);
    
    // Get all content entries and first order by slug (to group by category prefix)
    // Then order by order for proper page ordering within each category
    // Finally order by updatedAt and ID for any remaining ties
    const allContents = await db.select()
      .from(pageContents)
      .orderBy(
        pageContents.slug, 
        pageContents.order,
        desc(pageContents.updatedAt), 
        desc(pageContents.id)
      );
      
    // Track latest content for each unique slug - use Map to store slug -> content
    const slugToContentMap = new Map<string, PageContent>();
    
    for (const content of allContents) {
      // Skip hidden items when includeHidden is false
      if (!includeHidden && content.isHidden) {
        console.log(`Storage: Skipping hidden content for slug "${content.slug}" with ID ${content.id}`);
        continue;
      }
      
      // Only add the content if we haven't seen this slug yet
      // Since we're ordering by order, updatedAt and ID, the first occurrence should be the correctly ordered one
      if (!slugToContentMap.has(content.slug)) {
        slugToContentMap.set(content.slug, content);
        console.log(`Storage: Added content for slug "${content.slug}" with ID ${content.id} and order ${content.order}`);
      }
    }
    
    // Convert the map values to an array
    const latestContents = Array.from(slugToContentMap.values());
    
    // Sort the array by category (first part of slug before dash) and then by order
    latestContents.sort((a, b) => {
      // Extract category from slug (everything before the first dash or the whole slug if no dash)
      const catA = a.slug.split('-')[0];
      const catB = b.slug.split('-')[0];
      
      // First sort by category
      if (catA !== catB) {
        return catA.localeCompare(catB);
      }
      
      // Then sort by order within the same category
      return (a.order || 0) - (b.order || 0);
    });
    
    console.log(`Storage: Returning ${latestContents.length} unique page contents, sorted by category and order`);
    return latestContents;
  }

  async createPageContent(content: InsertPageContent): Promise<PageContent> {
    const [result] = await db.insert(pageContents)
      .values({
        ...content,
        mediaUrls: content.mediaUrls || [],
      })
      .returning();
    return result;
  }
  
  async deletePageContent(id: number): Promise<boolean> {
    try {
      const result = await db.delete(pageContents)
        .where(eq(pageContents.id, id))
        .returning();
      
      return result.length > 0;
    } catch (error) {
      console.error("Error deleting page content:", error);
      throw error;
    }
  }
  
  async deleteCommunityPages(): Promise<{ count: number, deletedIds: number[] }> {
    console.log("Storage: Deleting all community pages");
    try {
      // Find all community pages with slugs that contain 'community' (specifically those under Community Information)
      const communityPages = await db.select()
        .from(pageContents)
        .where(sql`${pageContents.slug} LIKE 'community-%'`)
        .execute();
      
      console.log("Found community pages:", JSON.stringify(communityPages));
      
      if (!communityPages || communityPages.length === 0) {
        console.log("Storage: No community pages found to delete");
        return { count: 0, deletedIds: [] };
      }
      
      // Process each page individually to avoid batch issues
      let deletedCount = 0;
      const deletedIds: number[] = [];
      
      for (const page of communityPages) {
        // Enhanced validation to catch any possible invalid ID cases
        const pageId = page.id;
        
        // Ensure ID is a valid number before attempting to use it in queries
        if (typeof pageId !== 'number' || isNaN(pageId) || !Number.isInteger(pageId) || pageId <= 0) {
          console.log(`Skipping page with invalid ID: ${pageId}, slug: ${page.slug}`);
          continue;
        }
        
        try {
          console.log(`Deleting content versions for page ID: ${pageId}, slug: ${page.slug}`);
          // Delete all content versions first - use explicit conversion to number
          await db.delete(contentVersions)
            .where(eq(contentVersions.contentId, Number(pageId)));
            
          console.log(`Deleting page content for ID: ${pageId}, slug: ${page.slug}`);
          // Then delete the page itself - use explicit conversion to number
          const result = await db.delete(pageContents)
            .where(eq(pageContents.id, Number(pageId)))
            .returning();
            
          if (result && result.length > 0) {
            deletedCount++;
            deletedIds.push(pageId);
            console.log(`Successfully deleted page ID: ${pageId}, slug: ${page.slug}`);
          }
        } catch (pageError) {
          console.error(`Error deleting page ID ${pageId}:`, pageError);
          // Continue with other pages even if one fails
        }
      }
      
      console.log(`Storage: Successfully deleted ${deletedCount} community pages`);
      return { 
        count: deletedCount, 
        deletedIds 
      };
    } catch (error) {
      console.error("Error deleting community pages:", error);
      throw error;
    }
  }
  
  /**
   * Delete all community-related pages from the "More" section
   * This deletes all page_contents with slugs that match community section patterns
   * like 'community-*', 'government-*', 'transportation-*', etc.
   */
  async deleteAllCommunityPages(): Promise<{ count: number, deletedIds: number[] }> {
    console.log("Storage: Deleting all community (more) pages");
    try {
      // Get all community-related categories
      const communityCategories = [
        'community',
        'government',
        'transportation',
        'religion',
        'amenities',
        'safety'
      ];
      
      // Create a list of all slugs to find
      const whereConditions = communityCategories.map(category => 
        sql`${pageContents.slug} LIKE ${`${category}-%`}`
      );
      
      // Find all community-related pages with these slugs
      const allPages = await db.select()
        .from(pageContents)
        .where(sql.or(...whereConditions))
        .execute();
      
      console.log(`Found ${allPages.length} community-related pages to delete`);
      
      if (!allPages || allPages.length === 0) {
        console.log("Storage: No community pages found to delete");
        return { count: 0, deletedIds: [] };
      }
      
      // Process each page individually to avoid batch issues
      let deletedCount = 0;
      const deletedIds: number[] = [];
      
      for (const page of allPages) {
        // Enhanced validation to catch any possible invalid ID cases
        const pageId = page.id;
        
        // Ensure ID is a valid number before attempting to use it in queries
        if (typeof pageId !== 'number' || isNaN(pageId) || !Number.isInteger(pageId) || pageId <= 0) {
          console.log(`Skipping page with invalid ID: ${pageId}, slug: ${page.slug}`);
          continue;
        }
        
        try {
          console.log(`Deleting content versions for page ID: ${pageId}, slug: ${page.slug}`);
          // Delete all content versions first - use explicit conversion to number
          await db.delete(contentVersions)
            .where(eq(contentVersions.contentId, Number(pageId)));
            
          console.log(`Deleting page content for ID: ${pageId}, slug: ${page.slug}`);
          // Then delete the page itself - use explicit conversion to number
          const result = await db.delete(pageContents)
            .where(eq(pageContents.id, Number(pageId)))
            .returning();
            
          if (result && result.length > 0) {
            deletedCount++;
            deletedIds.push(pageId);
            console.log(`Successfully deleted page ID: ${pageId}, slug: ${page.slug}`);
          }
        } catch (pageError) {
          console.error(`Error deleting page ID ${pageId}:`, pageError);
          // Continue with other pages even if one fails
        }
      }
      
      console.log(`Storage: Successfully deleted ${deletedCount} community pages`);
      return { 
        count: deletedCount, 
        deletedIds 
      };
    } catch (error) {
      console.error("Error deleting all community pages:", error);
      throw error;
    }
  }
  
  async updatePageSlugsForCategoryChange(oldSlug: string, newSlug: string): Promise<{ count: number, updatedIds: number[] }> {
    console.log(`Storage: Updating page slugs from category '${oldSlug}' to '${newSlug}'`);
    try {
      // Find all pages with slugs that start with the old category slug
      const affectedPages = await db.select()
        .from(pageContents)
        .where(sql`${pageContents.slug} LIKE ${oldSlug + '-%'}`)
        .execute();
      
      console.log(`Found ${affectedPages.length} pages with old category slug prefix`);
      
      if (!affectedPages || affectedPages.length === 0) {
        console.log(`Storage: No pages found with category slug prefix '${oldSlug}-'`);
        return { count: 0, updatedIds: [] };
      }
      
      // Process each page individually and create content versions
      let updatedCount = 0;
      const updatedIds: number[] = [];
      
      for (const page of affectedPages) {
        // Enhanced validation to catch any possible invalid ID cases
        const pageId = page.id;
        
        // Ensure ID is a valid number before attempting to use it in queries
        if (typeof pageId !== 'number' || isNaN(pageId) || !Number.isInteger(pageId) || pageId <= 0) {
          console.log(`Skipping page with invalid ID: ${pageId}, slug: ${page.slug}`);
          continue;
        }
        
        try {
          // Create a version record of the current content before updating
          await this.createContentVersionForUpdate(page);
          
          // Replace old slug prefix with new slug prefix
          const oldPageSlug = page.slug;
          const newPageSlug = page.slug.replace(new RegExp(`^${oldSlug}-`), `${newSlug}-`);
          
          console.log(`Updating page slug from '${oldPageSlug}' to '${newPageSlug}'`);
          
          // Update the page slug - use explicit conversion to number
          const result = await db.update(pageContents)
            .set({
              slug: newPageSlug,
              updatedAt: new Date()
            })
            .where(eq(pageContents.id, Number(pageId)))
            .returning();
            
          if (result && result.length > 0) {
            updatedCount++;
            updatedIds.push(pageId);
            console.log(`Successfully updated page ID: ${pageId}, slug: ${newPageSlug}`);
          }
        } catch (pageError) {
          console.error(`Error updating page ID ${pageId}:`, pageError);
          // Continue with other pages even if one fails
        }
      }
      
      console.log(`Storage: Successfully updated ${updatedCount} page slugs`);
      return { 
        count: updatedCount, 
        updatedIds 
      };
    } catch (error) {
      console.error("Error updating page slugs for category change:", error);
      throw error;
    }
  }
  
  // Helper method to create a content version before updating a page
  private async createContentVersionForUpdate(page: PageContent): Promise<void> {
    try {
      // Validate page ID before using it
      const pageId = page.id;
      if (typeof pageId !== 'number' || isNaN(pageId) || !Number.isInteger(pageId) || pageId <= 0) {
        console.error(`Cannot create content version: Invalid page ID: ${pageId}`);
        return;
      }
      
      const versionData = {
        contentId: Number(pageId),
        title: page.title,
        content: page.content,
        slug: page.slug,
        versionNotes: "Auto-saved before category slug update",
        createdAt: new Date(),
      };
      
      await db.insert(contentVersions).values(versionData);
      console.log(`Created version history for page ID: ${pageId}, slug: ${page.slug} before slug update`);
    } catch (error) {
      console.error(`Error creating content version for page ID ${pageId}:`, error);
      // Don't throw, just log the error and continue
    }
  }

  async updatePageContent(
    id: number, 
    data: Partial<PageContent>,
    options: { createVersion?: boolean; versionNotes?: string } = {}
  ): Promise<PageContent> {
    try {
      // Default options
      const { createVersion = true, versionNotes = "Automatic version created before update" } = options;
      
      // Get the current content to create a version record
      const currentContent = await this.getPageContentById(id);
      
      if (!currentContent) {
        throw new Error("Page content not found");
      }
      
      // Check if this is JSON content (for special handling)
      const isJsonContent = currentContent.slug === "banner-slides" || 
                           (currentContent.content && currentContent.content.startsWith('[') && 
                            currentContent.content.endsWith(']'));
                            
      console.log(`Content type for ${currentContent.slug}: ${isJsonContent ? 'JSON' : 'HTML'}`);
                            
      // Create a version of the current content before updating (if enabled)
      if (createVersion) {
        console.log(`Creating version for content ${id} before update with notes: "${versionNotes || 'Automatic version before update'}"`);
        try {
          const newVersion = await this.createContentVersionFromCurrent(currentContent, versionNotes);
          console.log(`SUCCESSFULLY CREATED VERSION #${newVersion.versionNumber} (ID: ${newVersion.id}) for content ID ${id}`);
        } catch (versionErr) {
          console.error(`CRITICAL ERROR: Failed to create version for content ${id}:`, versionErr);
          // Continue with the update even if version creation fails, but log the error prominently
        }
      } else {
        console.log(`Skipping version creation for content ID ${id} (explicitly disabled)`);
      }
      
      // Update the content
      const [result] = await db.update(pageContents)
        .set({
          ...data,
          updatedAt: new Date(),
        })
        .where(eq(pageContents.id, id))
        .returning();
      
      // Explicitly notify any listeners that content was updated
      try {
        await db.execute(sql`SELECT pg_notify('content_updated', ${id}::text)`);
      } catch (notifyErr) {
        console.warn(`Failed to send notification for content update: ${notifyErr}`);
      }
      
      return result;
    } catch (error) {
      console.error("Error updating page content:", error);
      throw error;
    }
  }
  
  /**
   * Get a page content by ID
   */
  private async getPageContentById(id: number): Promise<PageContent | undefined> {
    console.log("Getting page content by ID:", id);
    try {
      const result = await db.select().from(pageContents).where(eq(pageContents.id, id));
      return result[0];
    } catch (error) {
      console.error("Error retrieving page content by ID:", error);
      throw error;
    }
  }
  
  /**
   * Creates a content version from the current content
   * @param content - The content to create a version from
   * @param notes - Optional notes to include with the version
   */
  private async createContentVersionFromCurrent(
    content: PageContent, 
    notes: string = "Automatic version created before update"
  ): Promise<ContentVersion> {
    console.log(`Creating content version for content ID: ${content.id} with notes: "${notes}"`);
    
    try {
      // Get the latest version number for this content
      const latestVersion = await this.getLatestVersionNumber(content.id);
      const newVersionNumber = latestVersion + 1;
      
      // Detect content type for logging
      const isJsonContent = content.slug === "banner-slides" || 
                          (content.content && content.content.startsWith('[') && 
                           content.content.endsWith(']'));
      
      console.log(`Creating version #${newVersionNumber} for ${isJsonContent ? 'JSON' : 'HTML'} content type`);
      
      // Create the version record
      const versionData: InsertContentVersion = {
        contentId: content.id,
        slug: content.slug,
        title: content.title,
        content: content.content,
        mediaUrls: content.mediaUrls || [],
        createdBy: content.updatedBy ?? null,
        versionNumber: newVersionNumber,
        notes: notes
      };
      
      const [createdVersion] = await db.insert(contentVersions)
        .values(versionData)
        .returning();
        
      console.log(`Created content version #${newVersionNumber} with ID: ${createdVersion.id}`);
      return createdVersion;
    } catch (error) {
      console.error("Error creating content version:", error);
      throw error;
    }
  }
  
  /**
   * Gets the highest version number for a content
   */
  private async getLatestVersionNumber(contentId: number): Promise<number> {
    try {
      const result = await db.select({ maxVersion: sql`MAX(${contentVersions.versionNumber})` })
        .from(contentVersions)
        .where(eq(contentVersions.contentId, contentId));
        
      // If no versions exist, return 0 so the first version will be 1
      const maxVersion = result[0]?.maxVersion ?? 0;
      console.log(`Latest version number for content ${contentId} is ${maxVersion}`);
      return maxVersion;
    } catch (error) {
      console.error("Error getting latest version number:", error);
      return 0; // Default to 0 if there's an error
    }
  }
  
  // Content version history operations
  async getContentVersions(contentId: number): Promise<ContentVersion[]> {
    console.log("Getting content versions for content ID:", contentId);
    try {
      const results = await db.select()
        .from(contentVersions)
        .where(eq(contentVersions.contentId, contentId))
        .orderBy(desc(contentVersions.versionNumber));
      
      console.log(`Retrieved ${results.length} content versions`);
      return results;
    } catch (error) {
      console.error("Error retrieving content versions:", error);
      throw error;
    }
  }
  
  async getContentVersionsBySlug(slug: string): Promise<ContentVersion[]> {
    console.log("Getting content versions for slug:", slug);
    try {
      let query = db.select().from(contentVersions);
      
      // Check if this is a vendor page to enable special handling
      if (slug.startsWith('vendors-')) {
        console.log(`Vendor slug detected. Enabling flexible slug matching for "${slug}"`);
        
        // Split the slug to identify parts
        const parts = slug.split('-');
        if (parts.length >= 3) {
          const category = parts[1];
          const vendorName = parts.slice(2).join('-');
          
          // Create alternate formats for the slug
          const alternateFormats = [
            slug, // Original format: vendors-category-name
            `vendors-${category} ${vendorName}`, // Space format: vendors-category name
          ];
          
          console.log(`Will check multiple slug formats: ${alternateFormats.join(', ')}`);
          
          // Use OR condition to match any of these formats
          query = query.where(or(
            ...alternateFormats.map(format => eq(contentVersions.slug, format))
          ));
        } else {
          // If we can't identify parts, just use exact match
          query = query.where(eq(contentVersions.slug, slug));
        }
      } else {
        // For non-vendor pages, use exact match
        query = query.where(eq(contentVersions.slug, slug));
      }
      
      // Complete the query with ordering
      const results = await query.orderBy(desc(contentVersions.versionNumber));
      
      console.log(`Retrieved ${results.length} content versions for slug (with flexible matching)`);
      return results;
    } catch (error) {
      console.error("Error retrieving content versions by slug:", error);
      throw error;
    }
  }
  
  async createContentVersion(version: InsertContentVersion): Promise<ContentVersion> {
    console.log("Creating content version manually:", version);
    try {
      const [createdVersion] = await db.insert(contentVersions)
        .values(version)
        .returning();
        
      console.log("Manual content version created:", createdVersion);
      return createdVersion;
    } catch (error) {
      console.error("Error creating content version manually:", error);
      throw error;
    }
  }
  
  async restoreContentVersion(versionId: number): Promise<PageContent> {
    console.log("⏮️ RESTORING CONTENT FROM VERSION ID:", versionId);
    try {
      // Get the version to restore
      const versionResult = await db.select()
        .from(contentVersions)
        .where(eq(contentVersions.id, versionId));
      
      if (!versionResult || versionResult.length === 0) {
        console.error(`❌ ERROR: Content version with ID ${versionId} not found`);
        throw new Error(`Content version with ID ${versionId} not found`);
      }
      
      const version = versionResult[0];
      console.log(`✅ Found version to restore: ID=${version.id}, slug="${version.slug}", versionNumber=${version.versionNumber}`);
      
      // Special handling for vendor pages which might have multiple slug formats
      let versionSlug = version.slug;
      let currentContent: (typeof pageContents.$inferSelect) | null = null;
      
      // First try to find content with the exact version slug
      console.log(`🔍 Attempting to find content with exact slug: "${versionSlug}"`);
      currentContent = await this.getPageContent(versionSlug);
      
      // If we can't find content with exact slug and it's a vendor page, try alternate formats
      if (!currentContent && versionSlug.startsWith('vendors-')) {
        console.log(`🔄 Vendor page detected, trying alternate slug formats for "${versionSlug}"`);
        
        // Parse vendor information from the slug
        const parts = versionSlug.split('-');
        const baseType = parts[0]; // "vendors"
        
        if (parts.length >= 3) {
          const category = parts[1]; // e.g. "home-services"
          const vendorNameParts = parts.slice(2); // The rest of the slug
          
          // Try different variations of vendor slug formats
          const possibleSlugs = [
            // Original version slug
            versionSlug,
            
            // Try with different capitalization
            `${baseType}-${category.toUpperCase()}-${vendorNameParts.join('-')}`,
            
            // Try removing duplicates if present
            parts.some(p => p === parts[1] && parts.indexOf(p) > 1) ? 
              `${baseType}-${category}-${vendorNameParts.filter(p => p !== category).join('-')}` : null,
            
            // Try with simplified name if there are many parts
            vendorNameParts.length > 2 ?
              `${baseType}-${category}-${vendorNameParts[0]}-${vendorNameParts[vendorNameParts.length-1]}` : null 
          ].filter(Boolean) as string[];
          
          console.log(`🔍 Trying ${possibleSlugs.length} possible vendor slug variations:`, possibleSlugs);
          
          // Try each possible slug
          for (const slug of possibleSlugs) {
            if (!currentContent) {
              console.log(`🔍 Attempting to find content with alternate slug: "${slug}"`);
              currentContent = await this.getPageContent(slug);
              
              if (currentContent) {
                console.log(`✅ Found content with alternate slug: "${slug}"`);
                // Update the version slug to match the found content
                versionSlug = slug;
                break;
              }
            }
          }
          
          // If still no content, try a database search by substring
          if (!currentContent) {
            console.log(`🔍 Looking for partial matches in database for "${versionSlug}"`);
            
            // Try to find any content with a similar vendor slug
            const results = await db.select()
              .from(pageContents)
              .where(
                and(
                  like(pageContents.slug, `vendors-%`),
                  or(
                    like(pageContents.slug, `%-${vendorNameParts.join('-')}%`),
                    like(pageContents.slug, `%-${vendorNameParts.slice(-1)[0]}%`) // Match just last part
                  )
                )
              );
            
            if (results.length > 0) {
              console.log(`✅ Found ${results.length} potential matches for vendor by substring. Using first match: "${results[0].slug}"`);
              currentContent = results[0];
              versionSlug = results[0].slug;
            }
          }
        }
      }
      
      // If we still don't have content, proceed with emergency recovery
      if (!currentContent) {
        console.error(`❌ ERROR: Current content not found for version slug "${versionSlug}"`);
        
        // Emergency recovery: Create new content from this version
        console.log(`🚨 EMERGENCY RECOVERY: Creating new content from version ${versionId}`);
        const [newContent] = await db.insert(pageContents)
          .values({
            slug: versionSlug, // Use potentially updated slug for vendors
            title: version.title,
            content: version.content,
            mediaUrls: version.mediaUrls,
            createdAt: new Date(),
            updatedAt: new Date(),
            createdBy: version.createdBy,
            updatedBy: version.createdBy
          })
          .returning();
        
        console.log(`✅ CREATED NEW CONTENT: ID=${newContent.id}, slug="${newContent.slug}"`);
        
        // Update the version to point to the new content
        await db.update(contentVersions)
          .set({ contentId: newContent.id })
          .where(eq(contentVersions.id, versionId));
        
        console.log(`📝 Updated version ${versionId} to point to new content ID ${newContent.id}`);
        
        return newContent;
      }
      
      console.log(`Found current content: ID=${currentContent.id}, slug="${currentContent.slug}", title="${currentContent.title}"`);
      
      // Create a version of the current content before restoring
      try {
        const checkpointVersion = await this.createContentVersionFromCurrent(
          currentContent, 
          `Version created before restoring to version ${versionId}`
        );
        console.log(`Created checkpoint version ID ${checkpointVersion.id} before restore`);
      } catch (checkpointErr) {
        console.error(`WARNING: Failed to create checkpoint version: ${checkpointErr.message}`);
        // Continue with restoration even if checkpoint fails
      }
      
      // Check if this is JSON content (for special handling)
      const isJsonContent = version.slug === "banner-slides" || 
                          (version.content && version.content.startsWith('[') && 
                          version.content.endsWith(']'));
      
      console.log(`Restoring content type for ${version.slug}: ${isJsonContent ? 'JSON' : 'HTML'}`);
      
      let validContent = version.content;
      
      // Special handling for banner slides and JSON content
      if (isJsonContent) {
        console.log("Treating as JSON content for restore operation");
        // Parse and validate the JSON content before storing
        try {
          const jsonContent = JSON.parse(version.content);
          console.log("Successfully parsed JSON content for restore");
          // If we can parse it, we use a stringify version to ensure valid JSON
          validContent = JSON.stringify(jsonContent);
        } catch (err) {
          console.error("Error parsing JSON content during restoration:", err);
          console.log("Attempting to fix JSON content");
          
          // Emergency fix for JSON content
          try {
            // Try to extract array content and wrap in brackets
            const arrayMatches = version.content.match(/\[(.*)\]/s);
            if (arrayMatches && arrayMatches[0]) {
              const potentialJson = arrayMatches[0];
              JSON.parse(potentialJson); // Test if valid
              validContent = potentialJson;
              console.log("Successfully extracted and fixed JSON content");
            }
          } catch (fixErr) {
            console.error("Could not fix JSON content:", fixErr);
            // Use original content, but log the issue
          }
        }
      }
            
      // Update the current content with the version data
      const updateResult = await db.update(pageContents)
        .set({
          title: version.title,
          content: validContent,
          mediaUrls: version.mediaUrls,
          updatedAt: new Date(),
          // Keep the same updatedBy if available
          updatedBy: currentContent.updatedBy
        })
        .where(eq(pageContents.id, currentContent.id))
        .returning();
      
      if (!updateResult || updateResult.length === 0) {
        console.error(`CRITICAL ERROR: Content update failed for ID ${currentContent.id}`);
        throw new Error(`Content update failed for ID ${currentContent.id}`);
      }
      
      const restoredContent = updateResult[0];
        
      // Log the restored content for debugging
      console.log(`SUCCESSFULLY RESTORED content for slug "${version.slug}" (content length: ${restoredContent.content.length})`);
      
      // Explicitly clear any cached query results for this content
      try {
        await db.execute(sql`SELECT pg_notify('content_updated', ${restoredContent.id}::text)`);
      } catch (notifyErr) {
        console.warn(`Warning: Failed to notify of content update: ${notifyErr.message}`);
      }
      
      // Force extra cache invalidation
      setTimeout(async () => {
        try {
          console.log(`Refreshing version list for content ID ${restoredContent.id} after restore`);
          const versions = await db.select()
            .from(contentVersions)
            .where(eq(contentVersions.contentId, restoredContent.id))
            .orderBy(desc(contentVersions.versionNumber));
          console.log(`Found ${versions.length} versions for content ID ${restoredContent.id} after restore`);
        } catch (refreshErr) {
          console.error("Error refreshing version cache:", refreshErr);
        }
      }, 500);
      
      console.log("Content restored successfully:", restoredContent);
      return restoredContent;
    } catch (error) {
      console.error("Error restoring content version:", error);
      throw error;
    }
  }

  // Custom forms operations
  async getCustomForms(): Promise<CustomForm[]> {
    console.log("Getting all custom forms");
    try {
      const results = await db.select().from(customForms)
        .orderBy(desc(customForms.updatedAt));
      console.log(`Retrieved ${results.length} custom forms`);
      return results;
    } catch (error) {
      console.error("Error retrieving custom forms:", error);
      throw error;
    }
  }

  async getCustomForm(id: number): Promise<CustomForm | undefined> {
    console.log("Getting custom form with ID:", id);
    try {
      const result = await db.select().from(customForms).where(eq(customForms.id, id));
      console.log("Custom form retrieved successfully:", result[0]?.title);
      return result[0];
    } catch (error) {
      console.error("Error retrieving custom form:", error);
      throw error;
    }
  }

  async getCustomFormBySlug(slug: string): Promise<CustomForm | undefined> {
    console.log("Getting custom form with slug:", slug);
    try {
      const result = await db.select().from(customForms).where(eq(customForms.slug, slug));
      console.log("Custom form retrieved successfully:", result[0]?.title);
      return result[0];
    } catch (error) {
      console.error("Error retrieving custom form by slug:", error);
      throw error;
    }
  }
  


  async createCustomForm(form: InsertCustomForm): Promise<CustomForm> {
    console.log("Creating custom form:", form.title);
    try {
      const result = await db.insert(customForms).values({
        ...form,
        description: form.description || "",
        termsAndConditions: form.termsAndConditions || "",
        requiresTermsAcceptance: form.requiresTermsAcceptance || false,
        formFields: form.formFields || [],
        createdAt: new Date(),
        updatedAt: new Date()
      }).returning();
      
      console.log("Custom form created successfully with ID:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error creating custom form:", error);
      throw error;
    }
  }

  async updateCustomForm(id: number, data: Partial<CustomForm>): Promise<CustomForm> {
    console.log("Updating custom form with ID:", id);
    try {
      // First verify the form exists
      const existingForm = await db.select().from(customForms).where(eq(customForms.id, id));
      
      if (!existingForm.length) {
        throw new Error("Custom form not found");
      }
      
      // Remove the createdAt field if it exists - we shouldn't be updating this
      const { createdAt, ...updateData } = data;
      
      // Fix dates - ensure they're proper Date objects or remove them to let the DB handle them
      const cleanData = { ...updateData };
      
      // Perform the update
      const [updated] = await db.update(customForms)
        .set({
          ...cleanData,
          updatedAt: new Date()
        })
        .where(eq(customForms.id, id))
        .returning();
      
      if (!updated) {
        throw new Error("Failed to update custom form");
      }
      
      console.log("Custom form updated successfully:", updated.title);
      return updated;
    } catch (error) {
      console.error("Error updating custom form:", error);
      throw error;
    }
  }

  async deleteCustomForm(id: number): Promise<boolean> {
    console.log("Deleting custom form with ID:", id);
    try {
      // This implementation creates a shadow copy of the form with a negative ID first
      // and then points submissions to that form before deleting the original
      
      // 1. Get the form we want to delete
      const formToDelete = await db.select().from(customForms)
        .where(eq(customForms.id, id));
      
      if (formToDelete.length === 0) {
        console.log(`Form ${id} not found, nothing to delete`);
        return false;
      }
      
      const form = formToDelete[0];
      const negativeId = -Math.abs(id);
      
      // 2. Check if we already have a negative ID form (from a previous deletion attempt)
      const existingNegForm = await db.select().from(customForms)
        .where(eq(customForms.id, negativeId));
      
      if (existingNegForm.length > 0) {
        console.log(`Negative ID form ${negativeId} already exists, cleaning up...`);
        // Delete the existing negative ID form
        await db.delete(customForms)
          .where(eq(customForms.id, negativeId));
      }
      
      // 3. Check if there are any submissions that need preservation
      const submissions = await db.select().from(formSubmissions)
        .where(eq(formSubmissions.formId, id));
      
      console.log(`Found ${submissions.length} submissions for form ${id}`);
      
      if (submissions.length > 0) {
        // 4. Create a shadow copy of the form with negative ID to preserve structure
        try {
          // 4.1 Insert the shadow copy with a negative ID (marking it as deleted)
          // We need to do this as raw SQL to explicitly set the ID
          const insertQuery = `
            INSERT INTO custom_forms (
              id, title, description, form_fields, terms_and_conditions, 
              requires_terms_acceptance, slug, page_content_id, created_by, 
              created_at, updated_at
            ) VALUES (
              ${negativeId}, 
              '${form.title} (DELETED)', 
              ${form.description ? `'${form.description.replace(/'/g, "''")}'` : 'NULL'}, 
              '${JSON.stringify(form.formFields).replace(/'/g, "''")}'::jsonb, 
              ${form.termsAndConditions ? `'${form.termsAndConditions.replace(/'/g, "''")}'` : 'NULL'}, 
              ${form.requiresTermsAcceptance}, 
              '${form.slug}-deleted', 
              ${form.pageContentId ? form.pageContentId : 'NULL'}, 
              ${form.createdBy ? form.createdBy : 'NULL'}, 
              '${form.createdAt.toISOString()}', 
              NOW()
            )
          `;
          
          await db.execute(sql.raw(insertQuery));
          console.log(`Created shadow copy of form with ID ${negativeId}`);
          
          // 4.2 Now update the submissions to point to the negative ID form
          const updateQuery = `
            UPDATE form_submissions 
            SET form_id = ${negativeId} 
            WHERE form_id = ${id}
          `;
          
          await db.execute(sql.raw(updateQuery));
          console.log(`Updated ${submissions.length} submissions to reference shadow form ${negativeId}`);
        } catch (shadowError) {
          console.error("Error creating shadow form or updating submissions:", shadowError);
          throw shadowError;
        }
      }
      
      // 5. Now we can safely delete the original form
      const deleteResult = await db.delete(customForms)
        .where(eq(customForms.id, id))
        .returning();
      
      const success = deleteResult.length > 0;
      console.log(success ? 
        "Custom form deleted successfully - submissions preserved" : 
        "Failed to delete form"
      );
      
      return success;
    } catch (error) {
      console.error("Error deleting custom form:", error);
      throw error;
    }
  }

  // Form submissions operations
  async getFormSubmissions(formId: number): Promise<FormSubmission[]> {
    console.log("Getting submissions for form ID:", formId);
    try {
      // Handle both normal and deleted forms (negative IDs)
      // If form was deleted, the submissions would have -formId
      const absFormId = Math.abs(formId);
      const results = await db.select().from(formSubmissions)
        .where(sql`(${formSubmissions.formId} = ${formId} OR ${formSubmissions.formId} = ${-absFormId})`)
        .orderBy(desc(formSubmissions.createdAt));
      console.log(`Retrieved ${results.length} submissions for form ${formId}`);
      return results;
    } catch (error) {
      console.error("Error retrieving form submissions:", error);
      throw error;
    }
  }
  
  async getAllFormSubmissions(): Promise<FormSubmission[]> {
    console.log("Getting all form submissions");
    try {
      // Get all submissions including those from deleted forms (with negative formId)
      const results = await db.select().from(formSubmissions)
        .orderBy(desc(formSubmissions.createdAt));
        
      // Add a note for submissions from deleted forms
      const processedResults = results.map(submission => {
        // If the form ID is negative, it means the form was deleted
        // But we still want to show these submissions in the admin panel
        if (submission.formId < 0) {
          return {
            ...submission,
            // We don't modify the actual formId to maintain database integrity
            // This is just for display purposes in the admin UI
            _deletedForm: true, // Metadata flag to indicate this is from a deleted form
          };
        }
        return submission;
      });
      
      console.log(`Retrieved ${results.length} total form submissions`);
      return processedResults;
    } catch (error) {
      console.error("Error retrieving all form submissions:", error);
      throw error;
    }
  }

  async getFormSubmission(id: number): Promise<FormSubmission | undefined> {
    console.log("Getting form submission with ID:", id);
    try {
      const result = await db.select().from(formSubmissions).where(eq(formSubmissions.id, id));
      console.log("Form submission retrieved successfully:", result[0]?.id);
      
      if (result[0]) {
        // Add the _deletedForm flag if the formId is negative 
        // This indicates the form was deleted but submissions are preserved
        const submission = result[0];
        if (submission.formId < 0) {
          return {
            ...submission,
            _deletedForm: true, // Metadata flag to indicate this is from a deleted form
          };
        }
      }
      
      return result[0];
    } catch (error) {
      console.error("Error retrieving form submission:", error);
      throw error;
    }
  }

  async createFormSubmission(submission: InsertFormSubmission): Promise<FormSubmission> {
    console.log("Creating form submission for form ID:", submission.formId);
    try {
      // Format arrays properly
      const fileUploadsArray = Array.isArray(submission.fileUploads) ? submission.fileUploads : [];
      
      const result = await db.insert(formSubmissions).values({
        ...submission,
        fileUploads: fileUploadsArray,
        createdAt: new Date()
      }).returning();
      
      console.log("Form submission created successfully with ID:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error creating form submission:", error);
      throw error;
    }
  }

  // Order return operations
  async getOrderReturns(): Promise<OrderReturn[]> {
    console.log("Getting all order returns");
    try {
      const results = await db.select().from(orderReturns).orderBy(desc(orderReturns.createdAt));
      console.log(`Retrieved ${results.length} order returns`);
      return results;
    } catch (error) {
      console.error("Error retrieving order returns:", error);
      throw error;
    }
  }

  async getOrderReturnsByStatus(statuses: string[]): Promise<OrderReturn[]> {
    console.log(`Getting order returns with statuses: ${statuses.join(', ')}`);
    try {
      if (!statuses.length) {
        console.log('No statuses provided, returning empty array');
        return [];
      }
      
      // Build OR conditions for each status
      const statusConditions = statuses.map(status => eq(orderReturns.status, status));
      const results = await db.select().from(orderReturns).where(sql`${or(...statusConditions)}`);
      
      console.log(`Retrieved ${results.length} order returns with the requested statuses`);
      return results;
    } catch (error) {
      console.error("Error retrieving order returns by status:", error);
      throw error;
    }
  }

  async getOrderReturnsByOrder(orderId: number): Promise<OrderReturn[]> {
    console.log("Getting returns for order ID:", orderId);
    try {
      const results = await db.select().from(orderReturns).where(eq(orderReturns.orderId, orderId));
      console.log(`Retrieved ${results.length} returns for order ${orderId}`);
      return results;
    } catch (error) {
      console.error("Error retrieving order returns:", error);
      throw error;
    }
  }

  async getOrderReturnsByUser(userId: number): Promise<OrderReturn[]> {
    console.log("Getting returns for user ID:", userId);
    try {
      const results = await db.select()
        .from(orderReturns)
        .innerJoin(orders, eq(orderReturns.orderId, orders.id))
        .where(eq(orders.userId, userId));
      
      // Format the results to return only the OrderReturn objects
      const returns = results.map(r => r.orderReturns);
      console.log(`Retrieved ${returns.length} returns for user ${userId}`);
      return returns;
    } catch (error) {
      console.error("Error retrieving user returns:", error);
      throw error;
    }
  }

  async getOrderReturn(id: number): Promise<OrderReturn | undefined> {
    console.log("Getting order return with ID:", id);
    try {
      const result = await db.select().from(orderReturns).where(eq(orderReturns.id, id));
      console.log("Order return retrieved successfully:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error retrieving order return:", error);
      throw error;
    }
  }

  async createOrderReturn(orderReturn: InsertOrderReturn): Promise<OrderReturn> {
    console.log("Creating order return for order:", orderReturn.orderId);
    try {
      // Process arrays to ensure correct format
      const imageUrlsArray = Array.isArray(orderReturn.imageUrls) ? orderReturn.imageUrls : [];
      
      const result = await db.insert(orderReturns).values({
        ...orderReturn,
        imageUrls: imageUrlsArray,
        createdAt: new Date(),
        updatedAt: new Date(),
      }).returning();
      
      console.log("Order return created successfully with ID:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error creating order return:", error);
      throw error;
    }
  }

  async updateOrderReturn(id: number, data: Partial<OrderReturn>): Promise<OrderReturn> {
    console.log("Updating order return with ID:", id);
    try {
      const [updated] = await db.update(orderReturns)
        .set({
          ...data,
          updatedAt: new Date()
        })
        .where(eq(orderReturns.id, id))
        .returning();
      
      console.log("Order return updated successfully:", updated?.id);
      return updated;
    } catch (error) {
      console.error("Error updating order return:", error);
      throw error;
    }
  }

  async deleteOrderReturn(id: number): Promise<void> {
    console.log("Deleting order return with ID:", id);
    try {
      // First delete all related return items
      await db.transaction(async (tx) => {
        await tx.delete(returnItems).where(eq(returnItems.returnId, id));
        await tx.delete(orderReturns).where(eq(orderReturns.id, id));
      });
      console.log("Order return and all related items deleted successfully");
    } catch (error) {
      console.error("Error deleting order return:", error);
      throw error;
    }
  }
  
  // Return item operations
  async getReturnItems(returnId: number): Promise<ReturnItem[]> {
    console.log("Getting items for return ID:", returnId);
    try {
      const results = await db.select().from(returnItems).where(eq(returnItems.returnId, returnId));
      console.log(`Retrieved ${results.length} items for return ${returnId}`);
      return results;
    } catch (error) {
      console.error("Error retrieving return items:", error);
      throw error;
    }
  }

  async getReturnItem(id: number): Promise<ReturnItem | undefined> {
    console.log("Getting return item with ID:", id);
    try {
      const result = await db.select().from(returnItems).where(eq(returnItems.id, id));
      console.log("Return item retrieved successfully:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error retrieving return item:", error);
      throw error;
    }
  }

  async createReturnItem(returnItem: InsertReturnItem): Promise<ReturnItem> {
    console.log("Creating return item for return:", returnItem.returnId);
    try {
      const result = await db.insert(returnItems).values({
        ...returnItem,
        createdAt: new Date(),
      }).returning();
      
      console.log("Return item created successfully with ID:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error creating return item:", error);
      throw error;
    }
  }

  async updateReturnItem(id: number, data: Partial<ReturnItem>): Promise<ReturnItem> {
    console.log("Updating return item with ID:", id);
    try {
      const [updated] = await db.update(returnItems)
        .set(data)
        .where(eq(returnItems.id, id))
        .returning();
      
      console.log("Return item updated successfully:", updated?.id);
      return updated;
    } catch (error) {
      console.error("Error updating return item:", error);
      throw error;
    }
  }

  async deleteReturnItem(id: number): Promise<void> {
    console.log("Deleting return item with ID:", id);
    try {
      await db.delete(returnItems).where(eq(returnItems.id, id));
      console.log("Return item deleted successfully");
    } catch (error) {
      console.error("Error deleting return item:", error);
      throw error;
    }
  }

  /**
   * Preview which media files would be deleted without actually deleting them
   * This is a safe operation that just returns the list of files that would be deleted
   * @returns Object with count and list of files that would be deleted
   */
  async previewUnusedMedia(): Promise<{
    fileCount: number,
    filesToDelete: string[]
  }> {
    console.log("Previewing potentially unused media files - DISABLED PER USER REQUEST");
    console.log("Media cleanup has been disabled to prevent any files from being marked for deletion");
    
    // Return empty results - no files will be identified for deletion
    return {
      fileCount: 0,
      filesToDelete: []
    };
  }

  /**
   * Get all media file data - both referenced in database and existing in filesystem
   * Helper method used by both preview and delete operations
   */
  private async getMediaFileData(): Promise<{
    referencedUrls: Set<string>,
    allFiles: string[]
  }> {
    // Step 1: Get all file references from the database
    const eventResults = await db.select({ 
      id: events.id,
      mediaUrls: events.mediaUrls 
    }).from(events);
    const productResults = await db.select({ 
      imageUrls: products.imageUrls,
      mockupUrls: products.mockupUrls,
      designUrls: products.designUrls
    }).from(products);
    const listingResults = await db.select({ photos: realEstateListings.photos }).from(realEstateListings);
    const userResults = await db.select({ avatarUrl: users.avatarUrl }).from(users);
    
    // Also check page contents and content versions which may contain media URLs
    const pageContentResults = await db.select({ 
      content: pageContents.content, 
      mediaUrls: pageContents.mediaUrls 
    }).from(pageContents);
    
    const contentVersionResults = await db.select({ 
      content: contentVersions.content, 
      mediaUrls: contentVersions.mediaUrls 
    }).from(contentVersions);
    
    // Collect all referenced media URLs into a single Set for faster lookups
    const referencedUrls = new Set<string>();
    
    // CRITICAL: Explicitly preserve important files we know are referenced in the code
    // This ensures they're never deleted by media cleaning operations
    const criticalFiles = [
      '/uploads/icons/Asset1.svg',
      '/uploads/icons/rocket-icon.svg',
      '/uploads/banner-slides/bannerImage-1743595589741-190651491.mp4',
      '/static/videos/BackgroundVideo.mp4'
    ];
    
    // Add all critical files to the referenced URLs set
    criticalFiles.forEach(url => referencedUrls.add(url));
    
    // Process events
    eventResults.forEach(event => {
      if (Array.isArray(event.mediaUrls)) {
        event.mediaUrls.forEach(url => {
          if (url) referencedUrls.add(url);
        });
      }
    });
    
    // Process products
    productResults.forEach(product => {
      // Handle image URLs
      if (Array.isArray(product.imageUrls)) {
        product.imageUrls.forEach(url => {
          if (url) referencedUrls.add(url);
        });
      }
      
      // Handle mockup URLs
      if (Array.isArray(product.mockupUrls)) {
        product.mockupUrls.forEach(url => {
          if (url) referencedUrls.add(url);
        });
      }
      
      // Handle design URLs
      if (Array.isArray(product.designUrls)) {
        product.designUrls.forEach(url => {
          if (url) referencedUrls.add(url);
        });
      }
    });
    
    // Process real estate listings
    listingResults.forEach(listing => {
      if (Array.isArray(listing.photos)) {
        listing.photos.forEach(url => {
          if (url) referencedUrls.add(url);
        });
      }
    });
    
    // Process user avatars
    userResults.forEach(user => {
      if (user.avatarUrl) referencedUrls.add(user.avatarUrl);
    });
    
    // Process page contents
    pageContentResults.forEach(pageContent => {
      // First check the mediaUrls array
      if (Array.isArray(pageContent.mediaUrls)) {
        pageContent.mediaUrls.forEach(url => {
          if (url) referencedUrls.add(url);
        });
      }
      
      // Check if content might be JSON (like banner slides)
      if (pageContent.content) {
        try {
          // Try to parse the content as JSON
          const content = JSON.parse(pageContent.content);
          // If it's an array (like banner slides), extract src/url values
          if (Array.isArray(content)) {
            content.forEach(item => {
              // Check for src property (common in banner slides)
              if (item.src && typeof item.src === 'string' && item.src.startsWith('/uploads/')) {
                referencedUrls.add(item.src);
              }
              // Check for url property (used in some components)
              if (item.url && typeof item.url === 'string' && item.url.startsWith('/uploads/')) {
                referencedUrls.add(item.url);
              }
            });
          }
        } catch (e) {
          // Not JSON, scan for uploads URLs using regex
          this.extractUploadUrlsFromText(pageContent.content, referencedUrls);
        }
      }
    });
    
    // Process content versions - similar to page contents
    contentVersionResults.forEach(version => {
      // First check the mediaUrls array
      if (Array.isArray(version.mediaUrls)) {
        version.mediaUrls.forEach(url => {
          if (url) referencedUrls.add(url);
        });
      }
      
      // Check if content might be JSON (like banner slides)
      if (version.content) {
        try {
          // Try to parse the content as JSON
          const content = JSON.parse(version.content);
          // If it's an array (like banner slides), extract src/url values
          if (Array.isArray(content)) {
            content.forEach(item => {
              // Check for src property (common in banner slides)
              if (item.src && typeof item.src === 'string' && item.src.startsWith('/uploads/')) {
                referencedUrls.add(item.src);
              }
              // Check for url property (used in some components)
              if (item.url && typeof item.url === 'string' && item.url.startsWith('/uploads/')) {
                referencedUrls.add(item.url);
              }
            });
          }
        } catch (e) {
          // Not JSON, scan for uploads URLs using regex
          this.extractUploadUrlsFromText(version.content, referencedUrls);
        }
      }
    });
    
    // Add all files in the banner-slides directory to prevent accidental deletion
    // This helps ensure we don't lose banner videos and images
    const bannerSlidesDir = path.resolve(process.cwd(), 'uploads/banner-slides');
    if (fs.existsSync(bannerSlidesDir)) {
      try {
        const bannerFiles = fs.readdirSync(bannerSlidesDir);
        bannerFiles.forEach(file => {
          const url = `/uploads/banner-slides/${file}`;
          referencedUrls.add(url);
        });
        console.log(`Protected ${bannerFiles.length} banner slide files from deletion`);
      } catch (err) {
        console.error("Error reading banner slides directory:", err);
      }
    }
    
    // Add all files in the icons directory to prevent accidental deletion
    const iconsDir = path.resolve(process.cwd(), 'uploads/icons');
    if (fs.existsSync(iconsDir)) {
      try {
        const iconFiles = fs.readdirSync(iconsDir);
        iconFiles.forEach(file => {
          const url = `/uploads/icons/${file}`;
          referencedUrls.add(url);
        });
        console.log(`Protected ${iconFiles.length} icon files from deletion`);
      } catch (err) {
        console.error("Error reading icons directory:", err);
      }
    }
    
    console.log(`Found ${referencedUrls.size} referenced media files in the database`);
    
    // Step 2: Get all files in the uploads directory
    const uploadsDir = path.resolve(process.cwd(), 'uploads');
    console.log(`Using uploads directory: ${uploadsDir}`);
    
    // Read all files recursively from the uploads directory
    const allFiles = this.getAllFiles(uploadsDir);
    console.log(`Found ${allFiles.length} total files in uploads directory`);
    
    return { referencedUrls, allFiles };
  }
  
  // Helper function to extract all uploads URLs from text
  private extractUploadUrlsFromText(text: string | null, urlSet: Set<string>): void {
    if (!text) return;
    
    // Use regex to find all /uploads/ URLs in text content
    const uploadUrlRegex = /\/uploads\/[^"'\s)]+/g;
    const matches = text.match(uploadUrlRegex);
    
    if (matches) {
      matches.forEach(url => {
        urlSet.add(url);
      });
    }
  }
  
  // Helper function to get all files in a directory recursively
  private getAllFiles(dir: string, fileList: string[] = []): string[] {
    // Ensure directory exists before trying to read it
    if (!fs.existsSync(dir)) {
      console.log(`Directory does not exist: ${dir}`);
      return fileList;
    }
    
    const files = fs.readdirSync(dir);
    
    files.forEach(file => {
      const filePath = path.join(dir, file);
      if (fs.statSync(filePath).isDirectory()) {
        fileList = this.getAllFiles(filePath, fileList);
      } else {
        // Convert absolute path to the URL format used in the database (e.g., /uploads/image.jpg)
        const relativePath = filePath.split('uploads')[1];
        const urlPath = `/uploads${relativePath.replace(/\\/g, '/')}`;
        fileList.push(urlPath);
      }
    });
    
    return fileList;
  }

  /**
   * Cleanup function to delete all media files that are not referenced in the database
   * This is a destructive operation and should be used with caution
   * @returns Object with count of deleted files and their paths
   */
  async deleteUnusedMedia(fixMissingRefs = false, specificFiles?: string[]): Promise<{ 
    deletedCount: number, 
    deletedFiles: string[],
    fixedReferences?: {
      count: number,
      items: Array<{table: string, id: number, field: string, originalUrls: string[]}>
    }
  }> {
    console.log("Media cleanup has been disabled to prevent event photos from disappearing");
    // Return empty results - no files will be deleted
    return {
      deletedCount: 0,
      deletedFiles: [],
      fixedReferences: {
        count: 0,
        items: []
      }
    };
  }

  /**
   * Check for missing media files referenced in the database
   * This is a non-destructive operation that just reports missing files
   * @returns Object with count and details of missing files
   */
  async checkMissingMedia(): Promise<{
    missingCount: number,
    missingFiles: Array<{table: string, id: number, field: string, url: string}>
  }> {
    console.log("Missing media check has been disabled to prevent incorrect reporting");
    
    // Return empty results - no files will be reported as missing
    return {
      missingCount: 0,
      missingFiles: []
    };
  }
  
  /**
   * Helper method to filter array of URLs to only include existing files
   * This uses simple file system checks to validate URLs
   * @param urls - Array of URL paths to check
   * @returns Array of URL paths that exist in the filesystem
   */
  private async filterExistingFiles(urls: string[]): Promise<string[]> {
    if (!urls || !Array.isArray(urls)) return [];
    
    const validUrls: string[] = [];
    
    for (const url of urls) {
      try {
        // Convert URL to a file path
        let filePath = '';
        
        // If it's already an absolute path, resolve from the root
        if (url.startsWith('/')) {
          filePath = path.join(process.cwd(), url);
        } else {
          // Otherwise, treat as a relative path from the current directory
          filePath = path.resolve(url);
        }
        
        // Check if file exists
        if (fs.existsSync(filePath)) {
          validUrls.push(url);
        } else {
          console.log(`File does not exist: ${url}`);
        }
      } catch (error) {
        console.error(`Error checking file existence for ${url}:`, error);
      }
    }
    
    return validUrls;
  }
  
  async deleteOldContentVersions(): Promise<{ deletedCount: number }> {
    console.log("Content version cleanup has been DISABLED per user request");
    console.log("All content versions will be preserved to prevent any accidental media loss");
    
    // Return empty results - no versions will be deleted
    return { deletedCount: 0 };
  }
  
  // Forum Category Operations
  async getForumCategories(): Promise<ForumCategory[]> {
    console.log("Getting all forum categories");
    try {
      // First, get all the categories
      const categories = await db.select().from(forumCategories).orderBy(asc(forumCategories.order));
      
      // Then, for each category, count the number of posts
      const categoriesWithCounts = await Promise.all(
        categories.map(async (category) => {
          // Count posts for this category
          const postCountResult = await db.select({ 
            count: count() 
          })
          .from(forumPosts)
          .where(eq(forumPosts.categoryId, category.id));
          
          // Return the category with post count
          return {
            ...category,
            postCount: postCountResult[0]?.count || 0
          };
        })
      );
      
      console.log(`Retrieved ${categories.length} forum categories with post counts`);
      return categoriesWithCounts;
    } catch (error) {
      console.error("Error retrieving forum categories:", error);
      throw error;
    }
  }

  async getForumCategory(id: number): Promise<ForumCategory | undefined> {
    console.log("Getting forum category with ID:", id);
    try {
      const result = await db.select().from(forumCategories).where(eq(forumCategories.id, id));
      console.log("Forum category retrieved:", result[0]?.name);
      return result[0];
    } catch (error) {
      console.error("Error retrieving forum category:", error);
      throw error;
    }
  }

  async getForumCategoryBySlug(slug: string): Promise<ForumCategory | undefined> {
    console.log("Getting forum category with slug:", slug);
    try {
      const result = await db.select().from(forumCategories).where(eq(forumCategories.slug, slug));
      console.log("Forum category retrieved:", result[0]?.name);
      return result[0];
    } catch (error) {
      console.error("Error retrieving forum category by slug:", error);
      throw error;
    }
  }

  async createForumCategory(category: InsertForumCategory): Promise<ForumCategory> {
    console.log("Creating forum category:", category.name);
    try {
      const result = await db.insert(forumCategories).values(category).returning();
      console.log("Forum category created successfully with ID:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error creating forum category:", error);
      throw error;
    }
  }

  async updateForumCategory(id: number, data: Partial<ForumCategory>): Promise<ForumCategory> {
    console.log("Updating forum category with ID:", id);
    try {
      const [updated] = await db.update(forumCategories)
        .set({
          ...data,
          updatedAt: new Date()
        })
        .where(eq(forumCategories.id, id))
        .returning();
      
      console.log("Forum category updated successfully:", updated?.name);
      return updated;
    } catch (error) {
      console.error("Error updating forum category:", error);
      throw error;
    }
  }

  async deleteForumCategory(id: number): Promise<void> {
    console.log("Deleting forum category with ID:", id);
    try {
      // First, get all posts in this category to cascade delete them
      const posts = await db.select().from(forumPosts).where(eq(forumPosts.categoryId, id));
      
      // For each post, delete associated comments and reactions
      for (const post of posts) {
        // Get all comments for this post
        const comments = await db.select().from(forumComments).where(eq(forumComments.postId, post.id));
        
        // Delete reactions for comments
        for (const comment of comments) {
          await db.delete(forumReactions).where(eq(forumReactions.commentId, comment.id));
        }
        
        // Delete all reactions for the post
        await db.delete(forumReactions).where(eq(forumReactions.postId, post.id));
        
        // Delete all comments for the post
        await db.delete(forumComments).where(eq(forumComments.postId, post.id));
      }
      
      // Delete all posts in the category
      await db.delete(forumPosts).where(eq(forumPosts.categoryId, id));
      
      // Finally delete the category itself
      await db.delete(forumCategories).where(eq(forumCategories.id, id));
      
      console.log("Forum category and all associated content deleted successfully");
    } catch (error) {
      console.error("Error deleting forum category:", error);
      throw error;
    }
  }

  // Forum Post Operations
  async getForumPosts(categoryId?: number): Promise<ForumPost[]> {
    try {
      if (categoryId) {
        console.log("Getting forum posts for category ID:", categoryId);
        
        // Join with users table to get author information
        const results = await db.select({
          id: forumPosts.id,
          title: forumPosts.title,
          content: forumPosts.content,
          categoryId: forumPosts.categoryId,
          userId: forumPosts.userId,
          isPinned: forumPosts.isPinned,
          isLocked: forumPosts.isLocked,
          views: forumPosts.views,
          mediaUrls: forumPosts.mediaUrls,
          createdAt: forumPosts.createdAt,
          updatedAt: forumPosts.updatedAt,
          // Add author information
          author: {
            id: users.id,
            username: users.username,
            avatarUrl: users.avatarUrl
          }
        })
        .from(forumPosts)
        .leftJoin(users, eq(forumPosts.userId, users.id))
        .where(eq(forumPosts.categoryId, categoryId))
        .orderBy(desc(forumPosts.isPinned), desc(forumPosts.updatedAt));
        
        // Count comments for each post
        for (const post of results) {
          const commentCount = await db.select({ count: count() })
            .from(forumComments)
            .where(eq(forumComments.postId, post.id));
          
          post.commentCount = commentCount[0]?.count || 0;
        }
        
        console.log(`Retrieved ${results.length} forum posts for category ${categoryId}`);
        return results;
      } else {
        console.log("Getting all forum posts");
        
        // Join with users table to get author information
        const results = await db.select({
          id: forumPosts.id,
          title: forumPosts.title,
          content: forumPosts.content,
          categoryId: forumPosts.categoryId,
          userId: forumPosts.userId,
          isPinned: forumPosts.isPinned,
          isLocked: forumPosts.isLocked,
          views: forumPosts.views,
          mediaUrls: forumPosts.mediaUrls,
          createdAt: forumPosts.createdAt,
          updatedAt: forumPosts.updatedAt,
          // Add author information
          author: {
            id: users.id,
            username: users.username,
            avatarUrl: users.avatarUrl
          }
        })
        .from(forumPosts)
        .leftJoin(users, eq(forumPosts.userId, users.id))
        .orderBy(desc(forumPosts.isPinned), desc(forumPosts.updatedAt));
        
        // Count comments for each post
        for (const post of results) {
          const commentCount = await db.select({ count: count() })
            .from(forumComments)
            .where(eq(forumComments.postId, post.id));
          
          post.commentCount = commentCount[0]?.count || 0;
        }
        
        console.log(`Retrieved ${results.length} forum posts (all categories)`);
        return results;
      }
    } catch (error) {
      console.error("Error retrieving forum posts:", error);
      throw error;
    }
  }

  async getForumPost(id: number): Promise<ForumPost | undefined> {
    console.log("Getting forum post with ID:", id);
    try {
      // Join with users table to get author information and categories table to get category details
      const result = await db.select({
        id: forumPosts.id,
        title: forumPosts.title,
        content: forumPosts.content,
        categoryId: forumPosts.categoryId,
        userId: forumPosts.userId,
        isPinned: forumPosts.isPinned,
        isLocked: forumPosts.isLocked,
        views: forumPosts.views,
        mediaUrls: forumPosts.mediaUrls,
        createdAt: forumPosts.createdAt,
        updatedAt: forumPosts.updatedAt,
        // Add author information
        author: {
          id: users.id,
          username: users.username,
          avatarUrl: users.avatarUrl
        },
        // Add category information
        category: {
          id: forumCategories.id,
          name: forumCategories.name,
          slug: forumCategories.slug,
          description: forumCategories.description
        }
      })
      .from(forumPosts)
      .leftJoin(users, eq(forumPosts.userId, users.id))
      .leftJoin(forumCategories, eq(forumPosts.categoryId, forumCategories.id))
      .where(eq(forumPosts.id, id));

      if (result.length === 0) {
        return undefined;
      }

      // Count comments for the post
      const commentCount = await db.select({ count: count() })
        .from(forumComments)
        .where(eq(forumComments.postId, id));
      
      const post = result[0];
      post.commentCount = commentCount[0]?.count || 0;
      
      console.log("Forum post retrieved:", post.title);
      return post;
    } catch (error) {
      console.error("Error retrieving forum post:", error);
      throw error;
    }
  }

  async createForumPost(post: InsertForumPost): Promise<ForumPost> {
    console.log("Creating forum post:", post.title);
    try {
      // Ensure mediaUrls is properly formatted
      const mediaUrlsArray = Array.isArray(post.mediaUrls) ? post.mediaUrls : [];
      
      const result = await db.insert(forumPosts).values({
        ...post,
        mediaUrls: mediaUrlsArray,
        views: 0
      }).returning();
      
      console.log("Forum post created successfully with ID:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error creating forum post:", error);
      throw error;
    }
  }

  async updateForumPost(id: number, data: Partial<ForumPost>): Promise<ForumPost> {
    console.log("Updating forum post with ID:", id);
    try {
      const [updated] = await db.update(forumPosts)
        .set({
          ...data,
          updatedAt: new Date()
        })
        .where(eq(forumPosts.id, id))
        .returning();
      
      console.log("Forum post updated successfully:", updated?.title);
      return updated;
    } catch (error) {
      console.error("Error updating forum post:", error);
      throw error;
    }
  }

  async deleteForumPost(id: number): Promise<void> {
    console.log("Deleting forum post with ID:", id);
    try {
      // Delete all related comments and reactions first
      await db.transaction(async (tx) => {
        // First find all comments for this post (to delete reactions on them)
        const commentsResult = await tx.select({ id: forumComments.id })
          .from(forumComments)
          .where(eq(forumComments.postId, id));
        
        // Extract comment IDs
        const commentIds = commentsResult.map(c => c.id);
        
        // Delete reactions on comments (if any comments exist)
        if (commentIds.length > 0) {
          await tx.delete(forumReactions)
            .where(inArray(forumReactions.commentId, commentIds));
        }
        
        // Delete reactions on the post
        await tx.delete(forumReactions)
          .where(eq(forumReactions.postId, id));
        
        // Delete all comments
        await tx.delete(forumComments)
          .where(eq(forumComments.postId, id));
        
        // Finally delete the post
        await tx.delete(forumPosts)
          .where(eq(forumPosts.id, id));
      });
      
      console.log("Forum post and all related data deleted successfully");
    } catch (error) {
      console.error("Error deleting forum post:", error);
      throw error;
    }
  }

  async incrementPostViews(id: number): Promise<ForumPost> {
    console.log("Incrementing view count for forum post ID:", id);
    try {
      const post = await this.getForumPost(id);
      if (!post) {
        throw new Error("Forum post not found");
      }
      
      // Update the view count
      await db.update(forumPosts)
        .set({
          views: post.views + 1
        })
        .where(eq(forumPosts.id, id));
      
      // Return the full post with author information
      const updatedPost = await this.getForumPost(id);
      if (!updatedPost) {
        throw new Error("Updated forum post not found");
      }
      
      console.log("Forum post views incremented to:", updatedPost.views);
      return updatedPost;
    } catch (error) {
      console.error("Error incrementing forum post views:", error);
      throw error;
    }
  }

  // Forum Comment Operations
  async getForumComments(postId: number): Promise<ForumComment[]> {
    console.log("Getting comments for forum post ID:", postId);
    try {
      // Create a query using SQL to handle the column name mismatch
      const query = sql`
        SELECT 
          fc.id, 
          fc.content, 
          fc.post_id as "postId", 
          fc.author_id as "authorId",
          fc.created_at as "createdAt", 
          fc.updated_at as "updatedAt",
          jsonb_build_object(
            'id', u.id,
            'username', u.username,
            'avatarUrl', u.avatar_url
          ) as author
        FROM forum_comments fc
        LEFT JOIN users u ON fc.author_id = u.id
        WHERE fc.post_id = ${postId}
        ORDER BY fc.created_at
      `;
      
      const results = await db.execute(query);
      
      // Make sure we return an array, even if there are no comments
      const commentsArray = Array.isArray(results.rows) ? results.rows : [];
      console.log(`Retrieved ${commentsArray.length} comments for post ${postId}`);
      return commentsArray;
    } catch (error) {
      console.error("Error retrieving forum comments:", error);
      throw error;
    }
  }

  async getForumComment(id: number): Promise<ForumComment | undefined> {
    console.log("Getting forum comment with ID:", id);
    try {
      // Create a query using SQL to handle the column name mismatch
      const query = sql`
        SELECT 
          fc.id, 
          fc.content, 
          fc.post_id as "postId", 
          fc.author_id as "authorId",
          fc.created_at as "createdAt", 
          fc.updated_at as "updatedAt",
          jsonb_build_object(
            'id', u.id,
            'username', u.username,
            'avatarUrl', u.avatar_url
          ) as author
        FROM forum_comments fc
        LEFT JOIN users u ON fc.author_id = u.id
        WHERE fc.id = ${id}
      `;
      
      const results = await db.execute(query);
      console.log("Forum comment retrieved successfully");
      
      // Make sure we return the first row if it exists
      return results.rows && results.rows.length > 0 ? results.rows[0] : undefined;
    } catch (error) {
      console.error("Error retrieving forum comment:", error);
      throw error;
    }
  }

  async createForumComment(comment: InsertForumComment): Promise<ForumComment> {
    console.log("Creating forum comment for post:", comment.postId);
    try {
      // Use the correct column name (author_id) from the database schema
      const query = sql`
        INSERT INTO forum_comments 
        (content, post_id, author_id, created_at, updated_at) 
        VALUES (${comment.content}, ${comment.postId}, ${comment.authorId}, NOW(), NOW())
        RETURNING id, content, post_id AS "postId", author_id AS "authorId", created_at AS "createdAt", updated_at AS "updatedAt"
      `;
      
      const result = await db.execute(query);
      
      // Update the post's updatedAt timestamp when a new comment is added
      await db.update(forumPosts)
        .set({ updatedAt: new Date() })
        .where(eq(forumPosts.id, comment.postId));
      
      // Get the first row from the result if it exists
      const newComment = result.rows && result.rows.length > 0 ? result.rows[0] : null;
      console.log("Forum comment created successfully with ID:", newComment?.id);
      
      // Also get user information to attach to the comment
      if (newComment) {
        const user = await this.getUser(comment.authorId);
        newComment.author = {
          id: user?.id,
          username: user?.username,
          avatarUrl: user?.avatarUrl
        };
      }
      
      return newComment;
    } catch (error) {
      console.error("Error creating forum comment:", error);
      throw error;
    }
  }

  async updateForumComment(id: number, data: Partial<ForumComment>): Promise<ForumComment> {
    console.log("Updating forum comment with ID:", id);
    try {
      const [updated] = await db.update(forumComments)
        .set({
          ...data,
          updatedAt: new Date()
        })
        .where(eq(forumComments.id, id))
        .returning();
      
      console.log("Forum comment updated successfully:", updated?.id);
      return updated;
    } catch (error) {
      console.error("Error updating forum comment:", error);
      throw error;
    }
  }

  async deleteForumComment(id: number): Promise<void> {
    console.log("Deleting forum comment with ID:", id);
    try {
      // First delete any reactions on this comment
      await db.transaction(async (tx) => {
        await tx.delete(forumReactions)
          .where(eq(forumReactions.commentId, id));
        
        // Then delete the comment
        await tx.delete(forumComments)
          .where(eq(forumComments.id, id));
      });
      
      console.log("Forum comment deleted successfully");
    } catch (error) {
      console.error("Error deleting forum comment:", error);
      throw error;
    }
  }

  // Forum Reaction Operations
  async getForumReactions(postId?: number, commentId?: number): Promise<ForumReaction[]> {
    try {
      if (postId && !commentId) {
        console.log("Getting reactions for forum post ID:", postId);
        const results = await db.select().from(forumReactions)
          .where(eq(forumReactions.postId, postId));
        console.log(`Retrieved ${results.length} reactions for post ${postId}`);
        return results;
      } else if (!postId && commentId) {
        console.log("Getting reactions for forum comment ID:", commentId);
        const results = await db.select().from(forumReactions)
          .where(eq(forumReactions.commentId, commentId));
        console.log(`Retrieved ${results.length} reactions for comment ${commentId}`);
        return results;
      } else {
        console.log("Getting all forum reactions");
        const results = await db.select().from(forumReactions);
        console.log(`Retrieved ${results.length} forum reactions`);
        return results;
      }
    } catch (error) {
      console.error("Error retrieving forum reactions:", error);
      throw error;
    }
  }

  async createForumReaction(reaction: InsertForumReaction): Promise<ForumReaction> {
    console.log("Creating forum reaction of type:", reaction.reactionType);
    try {
      const result = await db.insert(forumReactions).values(reaction).returning();
      console.log("Forum reaction created successfully with ID:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error creating forum reaction:", error);
      throw error;
    }
  }

  async deleteForumReaction(id: number): Promise<void> {
    console.log("Deleting forum reaction with ID:", id);
    try {
      await db.delete(forumReactions).where(eq(forumReactions.id, id));
      console.log("Forum reaction deleted successfully");
    } catch (error) {
      console.error("Error deleting forum reaction:", error);
      throw error;
    }
  }

  async getForumReactionByUser(userId: number, postId?: number, commentId?: number): Promise<ForumReaction | undefined> {
    try {
      if (postId && !commentId) {
        console.log(`Getting user ${userId} reaction for post ${postId}`);
        const result = await db.select().from(forumReactions)
          .where(and(
            eq(forumReactions.userId, userId),
            eq(forumReactions.postId, postId)
          ));
        return result[0];
      } else if (!postId && commentId) {
        console.log(`Getting user ${userId} reaction for comment ${commentId}`);
        const result = await db.select().from(forumReactions)
          .where(and(
            eq(forumReactions.userId, userId),
            eq(forumReactions.commentId, commentId)
          ));
        return result[0];
      } else {
        console.error("Either postId or commentId must be provided");
        throw new Error("Invalid parameters: Either postId or commentId must be provided");
      }
    } catch (error) {
      console.error("Error retrieving user reaction:", error);
      throw error;
    }
  }
  
  // Forum Description Operations
  async getForumDescription(): Promise<ForumDescription | undefined> {
    console.log("Getting forum description");
    try {
      const result = await db.select().from(forumDescription).limit(1);
      console.log("Forum description retrieved:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error retrieving forum description:", error);
      throw error;
    }
  }
  
  async createForumDescription(description: InsertForumDescription): Promise<ForumDescription> {
    console.log("Creating forum description");
    try {
      // First check if there's already a description since we only want one record
      const existing = await this.getForumDescription();
      if (existing) {
        console.log("Forum description already exists, updating instead of creating new");
        return this.updateForumDescription(existing.id, description);
      }
      
      const result = await db.insert(forumDescription).values(description).returning();
      console.log("Forum description created successfully with ID:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error creating forum description:", error);
      throw error;
    }
  }
  
  async updateForumDescription(id: number, data: Partial<ForumDescription>): Promise<ForumDescription> {
    console.log("Updating forum description with ID:", id);
    try {
      const [updated] = await db.update(forumDescription)
        .set({
          ...data,
          updatedAt: new Date()
        })
        .where(eq(forumDescription.id, id))
        .returning();
      
      console.log("Forum description updated successfully:", updated?.id);
      return updated;
    } catch (error) {
      console.error("Error updating forum description:", error);
      throw error;
    }
  }
  
  // Delete all forum content
  async deleteAllForumContent(): Promise<{ deletedReactions: number, deletedComments: number, deletedPosts: number }> {
    console.log("Deleting all forum content");
    try {
      let deletedReactions = 0;
      let deletedComments = 0;
      let deletedPosts = 0;
      
      // Use raw SQL to avoid column name issues
      await db.transaction(async (tx) => {
        // 1. First delete all reactions (both on posts and comments)
        console.log("Deleting all forum reactions");
        const deleteReactionsQuery = await tx.execute(sql`DELETE FROM forum_reactions RETURNING *`);
        deletedReactions = deleteReactionsQuery.rows.length;
        console.log(`Deleted ${deletedReactions} forum reactions`);
        
        // 2. Delete all comments
        console.log("Deleting all forum comments");
        const deleteCommentsQuery = await tx.execute(sql`DELETE FROM forum_comments RETURNING *`);
        deletedComments = deleteCommentsQuery.rows.length;
        console.log(`Deleted ${deletedComments} forum comments`);
        
        // 3. Finally delete all posts
        console.log("Deleting all forum posts");
        const deletePostsQuery = await tx.execute(sql`DELETE FROM forum_posts RETURNING *`);
        deletedPosts = deletePostsQuery.rows.length;
        console.log(`Deleted ${deletedPosts} forum posts`);
      });
      
      console.log("All forum content successfully deleted");
      return { deletedReactions, deletedComments, deletedPosts };
    } catch (error) {
      console.error("Error deleting all forum content:", error);
      throw error;
    }
  }
  
  // Delete all forum comments only
  async deleteAllForumComments(): Promise<{ deletedReactions: number, deletedComments: number }> {
    console.log("Deleting all forum comments");
    try {
      let deletedReactions = 0;
      let deletedComments = 0;
      
      // Use raw SQL to avoid column name issues
      await db.transaction(async (tx) => {
        // 1. First delete all reactions that are on comments
        console.log("Deleting all forum comment reactions");
        const deleteReactionsQuery = await tx.execute(sql`DELETE FROM forum_reactions 
          WHERE comment_id IS NOT NULL RETURNING *`);
        deletedReactions = deleteReactionsQuery.rows.length;
        console.log(`Deleted ${deletedReactions} forum comment reactions`);
        
        // 2. Delete all comments
        console.log("Deleting all forum comments");
        const deleteCommentsQuery = await tx.execute(sql`DELETE FROM forum_comments RETURNING *`);
        deletedComments = deleteCommentsQuery.rows.length;
        console.log(`Deleted ${deletedComments} forum comments`);
      });
      
      console.log("All forum comments successfully deleted");
      return { deletedReactions, deletedComments };
    } catch (error) {
      console.error("Error deleting all forum comments:", error);
      throw error;
    }
  }

  // Vendor comment operations
  async getVendorComments(pageSlug: string): Promise<VendorComment[]> {
    console.log("Getting vendor comments for page slug:", pageSlug);
    try {
      const results = await db.select({
        id: vendorComments.id,
        content: vendorComments.content,
        createdAt: vendorComments.createdAt,
        updatedAt: vendorComments.updatedAt,
        pageSlug: vendorComments.pageSlug,
        userId: vendorComments.userId,
        user: {
          id: users.id,
          username: users.username,
          avatarUrl: users.avatarUrl,
          isResident: users.isResident
        }
      })
        .from(vendorComments)
        .leftJoin(users, eq(vendorComments.userId, users.id))
        .where(eq(vendorComments.pageSlug, pageSlug))
        .orderBy(desc(vendorComments.createdAt));
      
      console.log("Vendor comments retrieved successfully:", results);
      return results.map(result => ({
        ...result,
        user: result.user || null
      }));
    } catch (error) {
      console.error("Error retrieving vendor comments:", error);
      throw error;
    }
  }

  async createVendorComment(comment: InsertVendorComment): Promise<VendorComment> {
    console.log("Creating vendor comment:", comment);
    try {
      const result = await db.insert(vendorComments)
        .values(comment)
        .returning();
      console.log("Vendor comment created successfully:", result[0]);
      return result[0];
    } catch (error) {
      console.error("Error creating vendor comment:", error);
      throw error;
    }
  }

  async deleteVendorComment(id: number, userId: number): Promise<void> {
    console.log("Deleting vendor comment:", { id, userId });
    try {
      // If userId is 0, it means an admin is deleting the comment (admin override)
      // In this case, we don't check the userId and allow deleting any comment
      if (userId === 0) {
        // Admin override - can delete any comment
        await db.delete(vendorComments)
          .where(eq(vendorComments.id, id));
      } else {
        // Regular user can only delete their own comments
        await db.delete(vendorComments)
          .where(
            and(
              eq(vendorComments.id, id),
              eq(vendorComments.userId, userId)
            )
          );
      }
      console.log("Vendor comment deleted successfully");
    } catch (error) {
      console.error("Error deleting vendor comment:", error);
      throw error;
    }
  }

  // Vendor interaction operations
  async getVendorInteractions(pageSlug: string): Promise<VendorInteraction[]> {
    console.log("Getting vendor interactions for page slug:", pageSlug);
    try {
      const results = await db.select({
        id: vendorInteractions.id,
        pageSlug: vendorInteractions.pageSlug,
        userId: vendorInteractions.userId,
        interactionType: vendorInteractions.interactionType,
        createdAt: vendorInteractions.createdAt,
        user: {
          id: users.id,
          username: users.username,
          avatarUrl: users.avatarUrl,
          isResident: users.isResident
        }
      })
        .from(vendorInteractions)
        .leftJoin(users, eq(vendorInteractions.userId, users.id))
        .where(eq(vendorInteractions.pageSlug, pageSlug));
      
      console.log("Vendor interactions retrieved successfully:", results);
      return results.map(result => ({
        ...result,
        user: result.user || null
      }));
    } catch (error) {
      console.error("Error retrieving vendor interactions:", error);
      throw error;
    }
  }

  async getVendorInteraction(pageSlug: string, userId: number, type: string): Promise<VendorInteraction | undefined> {
    console.log("Getting vendor interaction:", { pageSlug, userId, type });
    try {
      const result = await db.select()
        .from(vendorInteractions)
        .where(
          and(
            eq(vendorInteractions.pageSlug, pageSlug),
            eq(vendorInteractions.userId, userId),
            eq(vendorInteractions.interactionType, type)
          )
        );
      console.log("Vendor interaction found:", result[0]);
      return result[0];
    } catch (error) {
      console.error("Error retrieving vendor interaction:", error);
      throw error;
    }
  }

  async createVendorInteraction(interaction: InsertVendorInteraction): Promise<VendorInteraction> {
    console.log("Creating vendor interaction:", interaction);
    try {
      const result = await db.insert(vendorInteractions)
        .values(interaction)
        .returning();
      console.log("Vendor interaction created successfully:", result[0]);
      return result[0];
    } catch (error) {
      console.error("Error creating vendor interaction:", error);
      throw error;
    }
  }

  async deleteVendorInteraction(pageSlug: string, userId: number, type: string): Promise<void> {
    console.log("Deleting vendor interaction:", { pageSlug, userId, type });
    try {
      await db.delete(vendorInteractions)
        .where(
          and(
            eq(vendorInteractions.pageSlug, pageSlug),
            eq(vendorInteractions.userId, userId),
            eq(vendorInteractions.interactionType, type)
          )
        );
      console.log("Vendor interaction deleted successfully");
    } catch (error) {
      console.error("Error deleting vendor interaction:", error);
      throw error;
    }
  }
  
  /**
   * Delete all vendors and their related records (comments, interactions)
   * This deletes all page_contents with slugs that start with "vendors-" 
   * and removes related vendor comments and interactions
   */
  async deleteAllVendors(): Promise<void> {
    console.log("Deleting all vendors and related records");
    try {
      await db.transaction(async (tx) => {
        // Get all vendor page slugs
        const vendorPages = await tx.select({ slug: pageContents.slug })
          .from(pageContents)
          .where(sql`${pageContents.slug} LIKE 'vendors-%'`);
        
        const vendorSlugs = vendorPages.map(page => page.slug);
        console.log(`Found ${vendorSlugs.length} vendor pages to delete`);
        
        if (vendorSlugs.length > 0) {
          // Delete all vendor comments and interactions
          await tx.delete(vendorComments)
            .where(inArray(vendorComments.pageSlug, vendorSlugs));
          
          await tx.delete(vendorInteractions)
            .where(inArray(vendorInteractions.pageSlug, vendorSlugs));
          
          // Delete all vendor pages
          const result = await tx.delete(pageContents)
            .where(inArray(pageContents.slug, vendorSlugs))
            .returning();
            
          console.log(`Successfully deleted ${result.length} vendor pages`);
        }
      });
      
      console.log("All vendors and related records deleted successfully");
    } catch (error) {
      console.error("Error deleting all vendors:", error);
      throw new Error("Failed to delete all vendors and related records");
    }
  }

  // Vendor category operations
  async getVendorCategories(includeHidden: boolean = false): Promise<VendorCategory[]> {
    console.log(`Getting all vendor categories (includeHidden: ${includeHidden})`);
    try {
      let query = db.select().from(vendorCategories);
      
      // Filter out hidden categories if includeHidden is false
      if (!includeHidden) {
        query = query.where(eq(vendorCategories.isHidden, false));
      }
      
      const results = await query.orderBy(asc(vendorCategories.order));
      console.log(`Retrieved ${results.length} vendor categories`);
      return results;
    } catch (error) {
      console.error("Error retrieving vendor categories:", error);
      throw error;
    }
  }

  async getVendorCategory(id: number): Promise<VendorCategory | undefined> {
    console.log("Getting vendor category with ID:", id);
    try {
      const result = await db.select().from(vendorCategories)
        .where(eq(vendorCategories.id, id));
      console.log("Vendor category retrieved:", result[0]?.name);
      return result[0];
    } catch (error) {
      console.error("Error retrieving vendor category:", error);
      throw error;
    }
  }

  async getVendorCategoryBySlug(slug: string): Promise<VendorCategory | undefined> {
    console.log("Getting vendor category with slug:", slug);
    try {
      const result = await db.select().from(vendorCategories)
        .where(eq(vendorCategories.slug, slug));
      console.log("Vendor category retrieved:", result[0]?.name);
      return result[0];
    } catch (error) {
      console.error("Error retrieving vendor category by slug:", error);
      throw error;
    }
  }

  async createVendorCategory(category: InsertVendorCategory): Promise<VendorCategory> {
    console.log("Creating vendor category:", category.name);
    try {
      const result = await db.insert(vendorCategories).values({
        ...category,
        createdAt: new Date(),
        updatedAt: new Date(),
      }).returning();
      
      console.log("Vendor category created successfully with ID:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error creating vendor category:", error);
      throw error;
    }
  }

  /**
   * Update page slugs when a vendor category slug changes
   * 
   * This function updates all page slugs that have "vendors-[oldSlug]" pattern,
   * replacing the old vendor category slug with the new one. It handles both hyphenated
   * formats (vendors-category-name) and space-separated formats (vendors-category name).
   * 
   * @param oldSlug - The old vendor category slug
   * @param newSlug - The new vendor category slug
   * @returns Object containing count of updated pages and array of updated page IDs
   */
  async updatePageSlugsForVendorCategoryChange(oldSlug: string, newSlug: string): Promise<{ count: number, updatedIds: number[] }> {
    console.log(`Updating vendor page slugs from "vendors-${oldSlug}-*" to "vendors-${newSlug}-*"`);
    try {
      // Find all pages with slugs that match vendor pages for this category:
      // 1. Standard format: "vendors-[oldSlug]-something"
      // 2. Space format: "vendors-[oldSlug] something"
      // 3. Special case formats (like home-service vs home-services)
      const dashPattern = 'vendors-' + oldSlug + '-%';
      const spacePattern = 'vendors-' + oldSlug + ' %';
      
      // Get pages with dash format
      const dashPages = await db.select()
        .from(pageContents)
        .where(sql`${pageContents.slug} LIKE ${dashPattern}`)
        .execute();
      
      // Get pages with space format
      const spacePages = await db.select()
        .from(pageContents)
        .where(sql`${pageContents.slug} LIKE ${spacePattern}`)
        .execute();
      
      // Combine both sets
      const pagesToUpdate = [...dashPages, ...spacePages];
      
      console.log(`Found ${pagesToUpdate.length} vendor pages with the old category slug pattern`);
      console.log(`- ${dashPages.length} pages with dash format`);
      console.log(`- ${spacePages.length} pages with space format`);
      
      if (pagesToUpdate.length === 0) {
        return { count: 0, updatedIds: [] };
      }
      
      // Store IDs of updated pages
      const updatedIds: number[] = [];
      
      // Process each page individually to maintain version history
      for (const page of pagesToUpdate) {
        try {
          let newPageSlug: string;
          
          // Handle both formats differently
          if (page.slug.includes(' ')) {
            // For space format: "vendors-category name" -> "vendors-newcategory name"
            newPageSlug = page.slug.replace(`vendors-${oldSlug} `, `vendors-${newSlug} `);
          } else {
            // For dash format: "vendors-category-name" -> "vendors-newcategory-name"
            newPageSlug = page.slug.replace(`vendors-${oldSlug}-`, `vendors-${newSlug}-`);
          }
          
          console.log(`Updating vendor page ${page.id}: "${page.slug}" -> "${newPageSlug}"`);
          
          // Update the page with the new slug and create a version record
          await this.updatePageContent(
            page.id, 
            { slug: newPageSlug },
            { 
              createVersion: true, 
              versionNotes: `Automatic update due to vendor category slug change from "${oldSlug}" to "${newSlug}"`
            }
          );
          
          updatedIds.push(page.id);
        } catch (pageUpdateError) {
          console.error(`Error updating vendor page ${page.id}:`, pageUpdateError);
          // Continue with other pages even if one fails
        }
      }
      
      // Handle special cases for common slug variations
      // For example: home-service vs home-services, food vs food-dining
      if (oldSlug === 'home-service' && newSlug === 'home-services' || 
          oldSlug === 'home-services' && newSlug === 'home-service' ||
          oldSlug === 'food' && newSlug === 'food-dining' ||
          oldSlug === 'food-dining' && newSlug === 'food' ||
          oldSlug === 'professional' && newSlug === 'professional-services' ||
          oldSlug === 'professional-services' && newSlug === 'professional'
      ) {
        console.log(`Handling special case slug variations for ${oldSlug} -> ${newSlug}`);
        
        // Add more special case handling as needed
      }
      
      return { 
        count: updatedIds.length,
        updatedIds
      };
    } catch (error) {
      console.error("Error updating vendor page slugs for category change:", error);
      throw error;
    }
  }

  async updateVendorCategory(id: number, data: Partial<VendorCategory>): Promise<VendorCategory> {
    console.log("Updating vendor category with ID:", id);
    try {
      // First verify the category exists
      const existingCategory = await db.select().from(vendorCategories)
        .where(eq(vendorCategories.id, id));
      
      if (!existingCategory.length) {
        throw new Error("Vendor category not found");
      }
      
      // Perform the update
      const [updated] = await db.update(vendorCategories)
        .set({
          ...data,
          updatedAt: new Date()
        })
        .where(eq(vendorCategories.id, id))
        .returning();
      
      if (!updated) {
        throw new Error("Failed to update vendor category");
      }
      
      console.log("Vendor category updated successfully:", updated.name);
      return updated;
    } catch (error) {
      console.error("Error updating vendor category:", error);
      throw error;
    }
  }

  async deleteVendorCategory(id: number): Promise<void> {
    console.log("Deleting vendor category with ID:", id);
    try {
      await db.delete(vendorCategories)
        .where(eq(vendorCategories.id, id));
      console.log("Vendor category deleted successfully");
    } catch (error) {
      console.error("Error deleting vendor category:", error);
      throw error;
    }
  }
  
  // Community category operations
  async getCommunityCategories(): Promise<CommunityCategory[]> {
    console.log("Getting all community categories");
    try {
      const results = await db.select().from(communityCategories)
        .orderBy(asc(communityCategories.order));
      console.log(`Retrieved ${results.length} community categories`);
      return results;
    } catch (error) {
      console.error("Error retrieving community categories:", error);
      throw error;
    }
  }

  async getCommunityCategory(id: number): Promise<CommunityCategory | undefined> {
    console.log("Getting community category with ID:", id);
    try {
      const result = await db.select().from(communityCategories)
        .where(eq(communityCategories.id, id));
      console.log("Community category retrieved:", result[0]?.name);
      return result[0];
    } catch (error) {
      console.error("Error retrieving community category:", error);
      throw error;
    }
  }

  async getCommunityCategoryBySlug(slug: string): Promise<CommunityCategory | undefined> {
    console.log("Getting community category with slug:", slug);
    try {
      const result = await db.select().from(communityCategories)
        .where(eq(communityCategories.slug, slug));
      console.log("Community category retrieved:", result[0]?.name);
      return result[0];
    } catch (error) {
      console.error("Error retrieving community category by slug:", error);
      throw error;
    }
  }

  async createCommunityCategory(category: InsertCommunityCategory): Promise<CommunityCategory> {
    console.log("Creating community category:", category.name);
    try {
      const result = await db.insert(communityCategories).values({
        ...category,
        createdAt: new Date(),
        updatedAt: new Date(),
      }).returning();
      
      console.log("Community category created successfully with ID:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error creating community category:", error);
      throw error;
    }
  }

  /**
   * Update page slugs when a community category slug changes
   * 
   * This function updates all page slugs that use the old category slug
   * as a prefix, replacing it with the new category slug.
   * 
   * @param oldSlug - The old category slug
   * @param newSlug - The new category slug
   * @returns Object containing count of updated pages and array of updated page IDs
   */
  async _deprecatedUpdatePageSlugsForCategoryChange(oldSlug: string, newSlug: string): Promise<{ count: number, updatedIds: number[] }> {
    console.log(`Updating page slugs from "${oldSlug}-*" to "${newSlug}-*"`);
    try {
      // Find all pages with slugs that start with the old category slug followed by a dash
      const pagesToUpdate = await db.select()
        .from(pageContents)
        .where(sql`${pageContents.slug} LIKE ${oldSlug + '-%'}`)
        .execute();
      
      console.log(`Found ${pagesToUpdate.length} pages with the old category slug prefix`);
      
      if (pagesToUpdate.length === 0) {
        return { count: 0, updatedIds: [] };
      }
      
      // Store IDs of updated pages
      const updatedIds: number[] = [];
      
      // Process each page individually to maintain version history
      for (const page of pagesToUpdate) {
        try {
          // Create the new slug by replacing the old category prefix with the new one
          const newPageSlug = page.slug.replace(`${oldSlug}-`, `${newSlug}-`);
          
          console.log(`Updating page ${page.id}: "${page.slug}" -> "${newPageSlug}"`);
          
          // Update the page with the new slug and create a version record
          await this.updatePageContent(
            page.id, 
            { slug: newPageSlug },
            { 
              createVersion: true, 
              versionNotes: `Automatic update due to category slug change from "${oldSlug}" to "${newSlug}"`
            }
          );
          
          updatedIds.push(page.id);
        } catch (pageUpdateError) {
          console.error(`Error updating page ${page.id}:`, pageUpdateError);
          // Continue with other pages even if one fails
        }
      }
      
      return { 
        count: updatedIds.length,
        updatedIds
      };
    } catch (error) {
      console.error("Error updating page slugs for category change:", error);
      throw error;
    }
  }

  async updateCommunityCategory(id: number, data: Partial<CommunityCategory>): Promise<CommunityCategory> {
    console.log("Updating community category with ID:", id);
    try {
      // First verify the category exists
      const existingCategory = await db.select().from(communityCategories)
        .where(eq(communityCategories.id, id));
      
      if (!existingCategory.length) {
        throw new Error("Community category not found");
      }
      
      // Perform the update
      const [updated] = await db.update(communityCategories)
        .set({
          ...data,
          updatedAt: new Date()
        })
        .where(eq(communityCategories.id, id))
        .returning();
      
      if (!updated) {
        throw new Error("Failed to update community category");
      }
      
      console.log("Community category updated successfully:", updated.name);
      return updated;
    } catch (error) {
      console.error("Error updating community category:", error);
      throw error;
    }
  }

  async deleteCommunityCategory(id: number): Promise<void> {
    console.log("Deleting community category with ID:", id);
    try {
      await db.delete(communityCategories)
        .where(eq(communityCategories.id, id));
      console.log("Community category deleted successfully");
    } catch (error) {
      console.error("Error deleting community category:", error);
      throw error;
    }
  }
  
  // Message operations
  async getMessage(id: number): Promise<Message | undefined> {
    console.log(`Getting message with ID: ${id}`);
    try {
      const results = await db.select().from(messages)
        .where(eq(messages.id, id));
      
      if (results.length === 0) {
        console.log(`No message found with ID: ${id}`);
        return undefined;
      }
      
      console.log(`Found message with ID: ${id}`);
      return results[0];
    } catch (error) {
      console.error("Error getting message by ID:", error);
      throw error;
    }
  }

  async getMessageWithRecipients(id: number): Promise<(Message & { recipients: MessageRecipient[] }) | undefined> {
    console.log(`Getting message with recipients, message ID: ${id}`);
    try {
      const result = await db.select().from(messages)
        .where(eq(messages.id, id));

      if (!result.length) {
        console.log(`No message found with ID: ${id}`);
        return undefined;
      }

      const message = result[0];
      
      const recipientsResult = await db.select().from(messageRecipients)
        .where(eq(messageRecipients.messageId, id));

      console.log(`Found message with ID: ${id} and ${recipientsResult.length} recipients`);
      return {
        ...message,
        recipients: recipientsResult
      };
    } catch (error) {
      console.error("Error getting message with recipients:", error);
      throw error;
    }
  }
  
  async getMessageRecipients(messageId: number): Promise<(MessageRecipient & { user?: Partial<User> })[]> {
    console.log(`Getting recipients for message ID: ${messageId} with user details`);
    try {
      // First get all recipients for this message
      const recipients = await db.select().from(messageRecipients)
        .where(eq(messageRecipients.messageId, messageId));
      
      if (recipients.length === 0) {
        console.log(`No recipients found for message ID: ${messageId}`);
        return [];
      }
      
      // For each recipient, get the user details
      const recipientsWithUsers = await Promise.all(
        recipients.map(async (recipient) => {
          // Get basic user info for the recipient
          const userResults = await db.select({
            id: users.id,
            username: users.username,
            fullName: users.fullName,
            role: users.role,
            avatarUrl: users.avatarUrl
          })
          .from(users)
          .where(eq(users.id, recipient.recipientId));
          
          if (userResults.length === 0) {
            return recipient;
          }
          
          return {
            ...recipient,
            user: userResults[0]
          };
        })
      );
      
      console.log(`Found ${recipientsWithUsers.length} recipients with user details for message ID: ${messageId}`);
      return recipientsWithUsers;
    } catch (error) {
      console.error("Error getting message recipients with user details:", error);
      throw error;
    }
  }

  async createMessage(message: InsertMessage, recipients: { recipientId: number, targetRole?: string }[]): Promise<Message> {
    console.log(`Creating new direct message from user ${message.senderId} to ${recipients.length} recipients`);
    try {
      // Insert the message
      const [newMessage] = await db.insert(messages).values(message).returning();
      console.log(`Created new message with ID: ${newMessage.id}`);

      // Insert all recipients
      if (recipients.length > 0) {
        const recipientRecords = recipients.map(r => ({
          messageId: newMessage.id,
          recipientId: r.recipientId,
          targetRole: r.targetRole,
          status: MessageStatus.UNREAD
        }));

        await db.insert(messageRecipients).values(recipientRecords);
        console.log(`Added ${recipients.length} recipients to message ${newMessage.id}`);
      }

      return newMessage;
    } catch (error) {
      console.error("Error creating message:", error);
      throw error;
    }
  }

  async createBroadcastMessage(message: InsertMessage, targetRole: string): Promise<Message> {
    console.log(`Creating broadcast message from user ${message.senderId} to role: ${targetRole}`);
    try {
      // Get all users with the target role
      const userResults = await db.select().from(users)
        .where(eq(users.role, targetRole));
      
      console.log(`Found ${userResults.length} users with role ${targetRole}`);

      // Create the message first
      const [newMessage] = await db.insert(messages).values(message).returning();
      console.log(`Created new broadcast message with ID: ${newMessage.id}`);

      if (userResults.length > 0) {
        // Create recipient records for all users with the target role
        const recipientRecords = userResults.map(user => ({
          messageId: newMessage.id,
          recipientId: user.id,
          targetRole: targetRole,
          status: MessageStatus.UNREAD
        }));

        await db.insert(messageRecipients).values(recipientRecords);
        console.log(`Added ${userResults.length} recipients to broadcast message ${newMessage.id}`);
      }

      return newMessage;
    } catch (error) {
      console.error("Error creating broadcast message:", error);
      throw error;
    }
  }

  async deleteMessage(id: number): Promise<boolean> {
    console.log(`Deleting message with ID: ${id}`);
    try {
      // Message recipients will be cascaded due to the foreign key constraint
      const result = await db.delete(messages)
        .where(eq(messages.id, id))
        .returning();
      
      const success = result.length > 0;
      console.log(`Message deletion ${success ? 'successful' : 'failed'} for ID: ${id}`);
      return success;
    } catch (error) {
      console.error("Error deleting message:", error);
      throw error;
    }
  }

  async getSentMessages(userId: number, page: number = 1, limit: number = 20): Promise<Message[]> {
    console.log(`Getting sent messages for user ID: ${userId}, page: ${page}, limit: ${limit}`);
    try {
      const offset = (page - 1) * limit;
      
      const result = await db.select().from(messages)
        .where(eq(messages.senderId, userId))
        .orderBy(desc(messages.createdAt))
        .limit(limit)
        .offset(offset);
      
      console.log(`Retrieved ${result.length} sent messages for user ID: ${userId}`);
      return result;
    } catch (error) {
      console.error("Error getting sent messages:", error);
      throw error;
    }
  }

  async getReceivedMessages(
    userId: number, 
    status: string = MessageStatus.UNREAD, 
    page: number = 1, 
    limit: number = 20
  ): Promise<MessageRecipient[]> {
    console.log(`Getting ${status} messages for user ID: ${userId}, page: ${page}, limit: ${limit}`);
    try {
      const offset = (page - 1) * limit;
      
      // Join with messages to get full message data
      const result = await db.select({
        ...messageRecipients,
        message: messages
      })
      .from(messageRecipients)
      .innerJoin(messages, eq(messageRecipients.messageId, messages.id))
      .where(
        and(
          eq(messageRecipients.recipientId, userId),
          status ? eq(messageRecipients.status, status) : undefined
        )
      )
      .orderBy(desc(messages.createdAt))
      .limit(limit)
      .offset(offset);
      
      console.log(`Retrieved ${result.length} ${status} messages for user ID: ${userId}`);
      
      // Transform the result to return MessageRecipient objects with message included
      return result.map(row => ({
        ...row,
        message: row.message
      })) as unknown as MessageRecipient[];
    } catch (error) {
      console.error("Error getting received messages:", error);
      throw error;
    }
  }

  async getUnreadMessageCount(userId: number): Promise<number> {
    console.log(`Getting unread message count for user ID: ${userId}`);
    try {
      const result = await db.select({ count: count() })
        .from(messageRecipients)
        .where(
          and(
            eq(messageRecipients.recipientId, userId),
            eq(messageRecipients.status, MessageStatus.UNREAD)
          )
        );
      
      const unreadCount = result[0]?.count || 0;
      console.log(`User ID: ${userId} has ${unreadCount} unread messages`);
      return unreadCount;
    } catch (error) {
      console.error("Error getting unread message count:", error);
      throw error;
    }
  }

  async markMessageAsRead(messageId: number, userId: number): Promise<boolean> {
    console.log(`Marking message ${messageId} as read for user ${userId}`);
    try {
      const now = new Date();
      const result = await db.update(messageRecipients)
        .set({ 
          status: MessageStatus.READ,
          readAt: now,
          updatedAt: now
        })
        .where(
          and(
            eq(messageRecipients.messageId, messageId),
            eq(messageRecipients.recipientId, userId)
          )
        )
        .returning();
      
      const success = result.length > 0;
      console.log(`Marking message as read ${success ? 'successful' : 'failed'} for message: ${messageId}, user: ${userId}`);
      return success;
    } catch (error) {
      console.error("Error marking message as read:", error);
      throw error;
    }
  }

  async markMessageAsArchived(messageId: number, userId: number): Promise<boolean> {
    console.log(`Archiving message ${messageId} for user ${userId}`);
    try {
      const now = new Date();
      const result = await db.update(messageRecipients)
        .set({ 
          status: MessageStatus.ARCHIVED,
          updatedAt: now
        })
        .where(
          and(
            eq(messageRecipients.messageId, messageId),
            eq(messageRecipients.recipientId, userId)
          )
        )
        .returning();
      
      const success = result.length > 0;
      console.log(`Archiving message ${success ? 'successful' : 'failed'} for message: ${messageId}, user: ${userId}`);
      return success;
    } catch (error) {
      console.error("Error archiving message:", error);
      throw error;
    }
  }
  
  // Feature flag operations
  async getFeatureFlags(): Promise<FeatureFlag[]> {
    console.log("Getting all feature flags");
    try {
      const results = await db.select().from(featureFlags);
      console.log(`Retrieved ${results.length} feature flags`);
      return results;
    } catch (error) {
      console.error("Error retrieving feature flags:", error);
      throw error;
    }
  }
  
  async getFeatureFlag(id: number): Promise<FeatureFlag | undefined> {
    console.log("Getting feature flag with ID:", id);
    try {
      const result = await db.select().from(featureFlags).where(eq(featureFlags.id, id));
      console.log("Feature flag retrieved successfully:", result[0]?.name);
      return result[0];
    } catch (error) {
      console.error("Error retrieving feature flag:", error);
      throw error;
    }
  }
  
  async getFeatureFlagByName(name: string): Promise<FeatureFlag | undefined> {
    console.log("Getting feature flag with name:", name);
    try {
      const result = await db.select().from(featureFlags).where(eq(featureFlags.name, name));
      console.log("Feature flag retrieved successfully:", result[0]?.displayName);
      return result[0];
    } catch (error) {
      console.error("Error retrieving feature flag by name:", error);
      throw error;
    }
  }
  
  async createFeatureFlag(featureFlag: InsertFeatureFlag): Promise<FeatureFlag> {
    console.log("Creating feature flag:", featureFlag.name);
    try {
      const result = await db.insert(featureFlags).values({
        ...featureFlag,
        createdAt: new Date(),
        updatedAt: new Date(),
      }).returning();
      
      console.log("Feature flag created successfully with ID:", result[0]?.id);
      return result[0];
    } catch (error) {
      console.error("Error creating feature flag:", error);
      throw error;
    }
  }
  
  async updateFeatureFlag(id: number, data: Partial<FeatureFlag>): Promise<FeatureFlag> {
    console.log("Updating feature flag with ID:", id);
    try {
      const [updated] = await db.update(featureFlags)
        .set({
          ...data,
          updatedAt: new Date()
        })
        .where(eq(featureFlags.id, id))
        .returning();
      
      console.log("Feature flag updated successfully:", updated?.name);
      return updated;
    } catch (error) {
      console.error("Error updating feature flag:", error);
      throw error;
    }
  }
  
  async deleteFeatureFlag(id: number): Promise<void> {
    console.log("Deleting feature flag with ID:", id);
    try {
      await db.delete(featureFlags).where(eq(featureFlags.id, id));
      console.log("Feature flag deleted successfully");
    } catch (error) {
      console.error("Error deleting feature flag:", error);
      throw error;
    }
  }
  
  async getVisibleFeaturesForRole(role: string): Promise<FeatureFlag[]> {
    console.log("Getting visible features for role:", role);
    try {
      // Get all active feature flags
      const allFlags = await db.select().from(featureFlags).where(eq(featureFlags.isActive, true));
      
      // Filter flags that are visible for the role
      const visibleFlags = allFlags.filter(flag => {
        return flag.enabledForRoles.includes(role);
      });
      
      console.log(`Found ${visibleFlags.length} visible features for role ${role}`);
      return visibleFlags;
    } catch (error) {
      console.error("Error getting visible features for role:", error);
      throw error;
    }
  }
  
  async initializeDefaultFeatureFlags(): Promise<FeatureFlag[]> {
    console.log("Initializing default feature flags");
    try {
      // Check if we already have feature flags
      const existingFlags = await this.getFeatureFlags();
      if (existingFlags.length > 0) {
        console.log("Feature flags already exist, skipping initialization");
        return existingFlags;
      }
      
      // Default feature flags with permissions following the updated role structure:
      // GUEST - Can browse but not interact
      // REGISTERED - Can view content and post for-sale listings
      // BADGE_HOLDERS - Can like/interact with events, vendors, and clubs
      // PAID - Full access to all features with commenting ability
      // MODERATOR - Same as PAID + moderation abilities
      // ADMIN - Full system access
      const defaultFlags = [
        {
          name: FeatureFlagName.CALENDAR,
          displayName: 'Calendar',
          enabledForRoles: [
            UserRole.GUEST, 
            UserRole.REGISTERED, 
            UserRole.BADGE_HOLDER, 
            UserRole.PAID, 
            UserRole.MODERATOR, 
            UserRole.ADMIN
          ] as string[],
          description: 'Community event calendar - All users can view',
          isActive: true,
        },
        {
          name: FeatureFlagName.FORUM,
          displayName: 'Forum',
          enabledForRoles: [
            UserRole.GUEST, 
            UserRole.REGISTERED, 
            UserRole.BADGE_HOLDER, 
            UserRole.PAID, 
            UserRole.MODERATOR, 
            UserRole.ADMIN
          ] as string[],
          description: 'Community discussion forums - All users can view',
          isActive: true,
        },
        {
          name: FeatureFlagName.FOR_SALE,
          displayName: 'For Sale',
          enabledForRoles: [
            UserRole.GUEST,
            UserRole.REGISTERED, 
            UserRole.BADGE_HOLDER, 
            UserRole.PAID, 
            UserRole.MODERATOR, 
            UserRole.ADMIN
          ] as string[],
          description: 'Community marketplace for listings',
          isActive: true,
        },
        {
          name: FeatureFlagName.STORE,
          displayName: 'Store',
          enabledForRoles: [
            UserRole.GUEST, 
            UserRole.REGISTERED, 
            UserRole.BADGE_HOLDER, 
            UserRole.PAID, 
            UserRole.MODERATOR, 
            UserRole.ADMIN
          ] as string[],
          description: 'Community merchandise store',
          isActive: true,
        },
        {
          name: FeatureFlagName.VENDORS,
          displayName: 'Vendors',
          enabledForRoles: [
            UserRole.GUEST, 
            UserRole.REGISTERED, 
            UserRole.BADGE_HOLDER, 
            UserRole.PAID, 
            UserRole.MODERATOR, 
            UserRole.ADMIN
          ] as string[],
          description: 'Preferred vendors directory',
          isActive: true,
        },
        {
          name: FeatureFlagName.COMMUNITY,
          displayName: 'Community',
          enabledForRoles: [
            UserRole.GUEST, 
            UserRole.REGISTERED, 
            UserRole.BADGE_HOLDER, 
            UserRole.PAID, 
            UserRole.MODERATOR, 
            UserRole.ADMIN
          ] as string[],
          description: 'Community information pages',
          isActive: true,
        },
        {
          name: FeatureFlagName.ADMIN,
          displayName: 'Admin Dashboard Access',
          enabledForRoles: [
            UserRole.ADMIN,
            UserRole.MODERATOR
          ] as string[],
          description: 'Access to the admin dashboard and all admin functionality',
          isActive: true,
        },
        {
          name: FeatureFlagName.MESSAGES,
          displayName: 'Messages',
          enabledForRoles: [
            UserRole.REGISTERED, 
            UserRole.BADGE_HOLDER, 
            UserRole.PAID, 
            UserRole.MODERATOR, 
            UserRole.ADMIN
          ] as string[],
          description: 'Private messaging between users',
          isActive: true,
        },
      ];
      
      // Create all default flags
      const createdFlags = [];
      for (const flag of defaultFlags) {
        const created = await this.createFeatureFlag(flag);
        createdFlags.push(created);
      }
      
      console.log(`Created ${createdFlags.length} default feature flags`);
      return createdFlags;
    } catch (error) {
      console.error("Error initializing default feature flags:", error);
      throw error;
    }
  }
  
  // Site settings operations
  async getSiteSettings(): Promise<SiteSetting[]> {
    console.log("Getting all site settings");
    try {
      const results = await db.select().from(siteSettings);
      console.log(`Retrieved ${results.length} site settings`);
      return results;
    } catch (error) {
      console.error("Error retrieving site settings:", error);
      throw error;
    }
  }
  
  async getSiteSetting(id: number): Promise<SiteSetting | undefined> {
    console.log("Getting site setting with ID:", id);
    try {
      const result = await db.select().from(siteSettings).where(eq(siteSettings.id, id));
      console.log("Site setting retrieved successfully:", result[0]?.key);
      return result[0];
    } catch (error) {
      console.error("Error retrieving site setting:", error);
      throw error;
    }
  }
  
  async getSiteSettingByKey(key: string): Promise<SiteSetting | undefined> {
    console.log("Getting site setting with key:", key);
    try {
      const result = await db.select().from(siteSettings).where(eq(siteSettings.key, key));
      console.log("Site setting retrieved successfully:", result[0]?.key);
      return result[0];
    } catch (error) {
      console.error("Error retrieving site setting by key:", error);
      throw error;
    }
  }
  
  async setSiteSetting(key: string, value: string, description?: string, userId?: number): Promise<SiteSetting> {
    console.log("Setting site setting:", key, "value:", value);
    try {
      // Check if setting already exists
      const existingSetting = await this.getSiteSettingByKey(key);
      
      if (existingSetting) {
        // Update existing setting
        const [updated] = await db.update(siteSettings)
          .set({
            value,
            description: description || existingSetting.description,
            updatedBy: userId || existingSetting.updatedBy,
            updatedAt: new Date()
          })
          .where(eq(siteSettings.key, key))
          .returning();
        
        console.log("Site setting updated successfully:", updated.key);
        return updated;
      } else {
        // Create new setting
        const [created] = await db.insert(siteSettings)
          .values({
            key,
            value,
            description,
            updatedBy: userId,
            createdAt: new Date(),
            updatedAt: new Date()
          })
          .returning();
        
        console.log("Site setting created successfully:", created.key);
        return created;
      }
    } catch (error) {
      console.error("Error setting site setting:", error);
      throw error;
    }
  }
  
  async deleteSiteSetting(id: number): Promise<boolean> {
    console.log("Deleting site setting with ID:", id);
    try {
      await db.delete(siteSettings).where(eq(siteSettings.id, id));
      console.log("Site setting deleted successfully");
      return true;
    } catch (error) {
      console.error("Error deleting site setting:", error);
      return false;
    }
  }
  
  async getSettingValue(key: string): Promise<string | null> {
    console.log("Getting site setting value for key:", key);
    try {
      const setting = await this.getSiteSettingByKey(key);
      if (setting) {
        console.log(`Found value for setting ${key}: ${setting.value}`);
        return setting.value;
      }
      console.log(`No value found for setting ${key}`);
      return null;
    } catch (error) {
      console.error("Error retrieving setting value:", error);
      return null;
    }
  }
}

export const storage = new DatabaseStorage();