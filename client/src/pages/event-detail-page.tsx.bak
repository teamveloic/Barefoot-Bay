import { useState } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useParams, useLocation } from "wouter";
import { CalendarDays, MapPin, Clock, MessageSquare, ThumbsUp, Users, Phone, Mail, Globe, Building2, Pencil, Trash2, AlertTriangle, Eye, EyeOff, CreditCard, BanIcon } from "lucide-react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { UserAvatar } from "@/components/shared/user-avatar";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { CreateEventForm, type EventFormData } from "@/components/calendar/create-event-form";
import { useAuth } from "@/hooks/use-auth";
import { usePermissions } from "@/hooks/use-permissions";
import { type Event, type InteractionWithUser, type CommentWithUser } from "@shared/schema";
import { queryClient, apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { format } from "date-fns";
import { UserAvatarCarousel } from "@/components/calendar/user-avatar-carousel";
import { LocationMapAlt } from "@/components/calendar/location-map-alt";
import { EventMediaGallery } from "@/components/calendar/event-media-gallery";
import {Badge} from "@/components/ui/badge" //Import Badge component
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";


// keep existing type definitions

const formatHoursOfOperation = (hours: any) => {
  if (!hours) return "Not specified";

  const days = Object.entries(hours).map(([day, schedule]: [string, any]) => {
    if (!schedule.isOpen) return `${day}: Closed`;
    return `${day}: ${schedule.openTime} - ${schedule.closeTime}`;
  });

  return days.join('\n');
};

export default function EventDetailPage() {
  const { id } = useParams<{ id: string }>();
  const [, setLocation] = useLocation();
  const { user } = useAuth();
  const { isAdmin, canInteractWithEvent, canCommentOnEvent } = usePermissions();
  const { toast } = useToast();
  const [comment, setComment] = useState("");
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [showContactInfo, setShowContactInfo] = useState(false);
  const [isCreateDuplicateDialogOpen, setIsCreateDuplicateDialogOpen] = useState(false);
  const [isRecurringEditDialogOpen, setIsRecurringEditDialogOpen] = useState(false);
  const [isDeleteSeriesDialogOpen, setIsDeleteSeriesDialogOpen] = useState(false);
  const [editMode, setEditMode] = useState<'occurrence' | 'series' | null>(null);
  
  // Add mutation for deleting comments
  const deleteCommentMutation = useMutation({
    mutationFn: async (commentId: number) => {
      console.log("Deleting comment:", commentId);
      
      // Use the apiRequest function for consistent authentication credentials handling
      const response = await apiRequest("DELETE", `/api/events/comments/${commentId}`);
      
      if (!response.ok) {
        throw new Error("Failed to delete comment");
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/events", parseInt(id), "comments"] });
      toast({
        title: "Success",
        description: "Comment deleted successfully"
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message || "Failed to delete comment",
        variant: "destructive"
      });
    }
  });
  //Removed selectedFiles State, using mediaFiles in the form instead.

  const { data: event, isLoading: isEventLoading, error: eventError } = useQuery<Event>({
    queryKey: ["/api/events", parseInt(id)],
    queryFn: async () => {
      console.log("Fetching event details for:", id);
      const response = await apiRequest("GET", `/api/events/${id}`);
      if (!response.ok) {
        throw new Error("Failed to fetch event details");
      }
      return response.json();
    },
  });

  const { data: interactions = [] } = useQuery<InteractionWithUser[]>({
    queryKey: ["/api/events", parseInt(id), "interactions"],
    queryFn: async () => {
      console.log("Fetching event interactions for:", id);
      const response = await apiRequest("GET", `/api/events/${id}/interactions`);
      if (!response.ok) {
        throw new Error("Failed to fetch event interactions");
      }
      return response.json();
    },
    enabled: !!event,
  });

  const { data: comments = [] } = useQuery<CommentWithUser[]>({
    queryKey: ["/api/events", parseInt(id), "comments"],
    queryFn: async () => {
      console.log("Fetching event comments for:", id);
      const response = await apiRequest("GET", `/api/events/${id}/comments`);
      if (!response.ok) {
        throw new Error("Failed to fetch event comments");
      }
      return response.json();
    },
    enabled: !!event,
  });

  const interactionMutation = useMutation({
    mutationFn: async (type: "like" | "going" | "interested") => {
      console.log("Submitting interaction:", { type, eventId: id, user: user?.id });
      
      // Use the apiRequest function instead of fetch directly to ensure
      // consistent handling of authentication credentials
      const response = await apiRequest("POST", `/api/events/${id}/interactions`, { type });
      return await response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/events", parseInt(id), "interactions"] });
      toast({
        title: "Success",
        description: "Your interaction has been recorded",
      });
    },
    onError: (error: Error) => {
      console.error("Interaction error:", error);
      toast({
        title: "Error",
        description: error.message || "Failed to interact with event",
        variant: "destructive",
      });
    },
  });

  const commentMutation = useMutation({
    mutationFn: async (content: string) => {
      console.log("Submitting comment:", { content, eventId: id, user: user?.id });
      
      // Use the apiRequest function instead of fetch directly to ensure
      // consistent handling of authentication credentials
      const response = await apiRequest("POST", `/api/events/${id}/comments`, { content });
      return await response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/events", parseInt(id), "comments"] });
      setComment("");
      toast({
        title: "Success",
        description: "Your comment has been posted"
      });
    },
    onError: (error: Error) => {
      console.error("Comment error:", error);
      toast({
        title: "Error",
        description: error.message || "Failed to post comment",
        variant: "destructive"
      });
    }
  });

  const updateEventMutation = useMutation({
    mutationFn: async (data: EventFormData & { existingMediaToRemove?: string[], mediaFiles?: FileList | null }) => {
      console.log("updateEventMutation.mutationFn called with data:", data);
      
      try {
        // Ensure endDate is after startDate
        const startDate = new Date(data.startDate);
        const endDate = new Date(data.endDate);
        
        // If endDate is before startDate, add 1 hour to endDate
        if (endDate <= startDate) {
          const newEndDate = new Date(startDate);
          newEndDate.setHours(startDate.getHours() + 1);
          data.endDate = newEndDate;
          console.log("Adjusted endDate to be after startDate:", newEndDate);
        }
        
        const formData = new FormData();

        // Add any new media files
        if (data.mediaFiles) {
          console.log("Adding media files to FormData:", data.mediaFiles.length, "files");
          for (let i = 0; i < data.mediaFiles.length; i++) {
            formData.append('media', data.mediaFiles[i]);
          }
        }

        // Enhanced media handling - properly track which files to keep and which to remove
        const currentMediaUrls = event?.mediaUrls || [];
        
        // Ensure data.existingMediaToRemove is an array
        const mediaToRemove = Array.isArray(data.existingMediaToRemove) 
          ? data.existingMediaToRemove 
          : (typeof data.existingMediaToRemove === 'string' 
              ? [data.existingMediaToRemove] 
              : []);
        
        // Log the media removal data for debugging
        console.log("Current media URLs:", currentMediaUrls);
        console.log("Media marked for removal (raw):", data.existingMediaToRemove);
        console.log("Media marked for removal (normalized):", mediaToRemove);
        
        // Filter out media URLs that are marked for removal
        const mediaUrlsToKeep = currentMediaUrls.filter(
          url => !mediaToRemove.includes(url)
        );
        console.log("Media URLs to keep:", mediaUrlsToKeep);

        // Clean up contact info fields
        const cleanContactInfo = data.contactInfo ? Object.fromEntries(
          Object.entries(data.contactInfo)
            .filter(([_, value]) => value && value.trim() !== '')
        ) : undefined;

        // Prepare the event data
        const eventData = {
          title: data.title.trim(),
          startDate: new Date(data.startDate).toISOString(),
          endDate: new Date(data.endDate).toISOString(),
          location: data.location.trim(),
          description: data.description?.trim() || undefined,
          category: data.category,
          businessName: data.businessName?.trim() || undefined,
          contactInfo: Object.keys(cleanContactInfo || {}).length > 0 ? cleanContactInfo : undefined,
          // Include badge required field
          badgeRequired: data.badgeRequired === true,
          // Handle the hours of operation, explicitly converting between string 'null' and actual null
          hoursOfOperation: data.hoursOfOperation === 'null' || data.hoursOfOperation === null ? 
            null : // Important: Set to real null when the hours are toggled off
            (data.hoursOfOperation ? 
              (typeof data.hoursOfOperation === 'string' ? 
                JSON.parse(data.hoursOfOperation) : 
                data.hoursOfOperation) : 
              undefined),
          mediaUrls: mediaUrlsToKeep,
          // Include the explicitly marked files for removal for server-side processing
          existingMediaToRemove: mediaToRemove,
          // Handle recurring event data
          isRecurring: data.isRecurring,
          recurrenceFrequency: data.isRecurring && data.recurrenceFrequency ? 
            // Normalize frequency: convert to lowercase and replace "bi-weekly" with "biweekly"
            data.recurrenceFrequency.toLowerCase().replace('bi-weekly', 'biweekly') : null,
          recurrenceEndDate: data.isRecurring && data.recurrenceEndDate ? 
            new Date(data.recurrenceEndDate).toISOString() : null
        };
        
        // Debug the final eventData that's going to be sent
        console.log("Final eventData for PATCH:", { 
          ...eventData,
          hoursOfOperationRaw: data.hoursOfOperation,
          hoursOfOperationType: typeof data.hoursOfOperation,
          hoursOfOperationIsNull: data.hoursOfOperation === 'null'
        });

        // Always add existingMediaToRemove as a separate field in formData for better tracking
        // Even if it's empty, so the server knows we're checking for media removal
        console.log("Adding media removal information to FormData:", mediaToRemove);
        const removalDataString = JSON.stringify(mediaToRemove);
        formData.append('existingMediaToRemove', removalDataString);

        // Add the event data as a JSON string
        // Include the edit mode when updating recurring events
        if (event?.isRecurring && editMode) {
          console.log(`Updating recurring event with mode: ${editMode}`);
          eventData.editMode = editMode;
        }

        const eventDataString = JSON.stringify(eventData);
        console.log("Adding eventData to FormData:", eventDataString.substring(0, 100) + "...");
        formData.append('eventData', eventDataString);

        console.log("Sending PATCH request to:", `/api/events/${id}`);
        // Use apiRequest for consistent authentication handling
        const response = await apiRequest({
          url: `/api/events/${id}`,
          method: 'PATCH',
          body: formData
        });

        console.log("PATCH response status:", response.status);
        
        if (!response.ok) {
          const contentType = response.headers.get("content-type");
          if (contentType?.includes("application/json")) {
            const errorData = await response.json();
            console.error("PATCH error response:", errorData);
            throw new Error(errorData.message || "Failed to update event");
          }
          throw new Error(`Failed to update event: ${response.status} ${response.statusText}`);
        }

        console.log("PATCH request successful");
        return response.json();
      } catch (error) {
        console.error("Error in updateEventMutation.mutationFn:", error);
        throw error;
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/events"] });
      queryClient.invalidateQueries({ queryKey: ["/api/events", parseInt(id)] });
      setIsEditDialogOpen(false);
      // setSelectedFiles([]); // Removed as selectedFiles is no longer used.
      toast({
        title: "Success",
        description: "Event updated successfully"
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive"
      });
    }
  });

  const createEventMutation = useMutation({
    mutationFn: async (data: EventFormData & { existingMediaToRemove?: string[], mediaFiles?: FileList | null }) => {
      console.log("Creating a new event from duplicate with data:", data);
      
      try {
        // Ensure endDate is after startDate
        const startDate = new Date(data.startDate);
        const endDate = new Date(data.endDate);
        
        // If endDate is before startDate, add 1 hour to endDate
        if (endDate <= startDate) {
          const newEndDate = new Date(startDate);
          newEndDate.setHours(startDate.getHours() + 1);
          data.endDate = newEndDate;
          console.log("Adjusted endDate to be after startDate:", newEndDate);
        }
        
        const formData = new FormData();

        // Add any new media files
        if (data.mediaFiles) {
          console.log("Adding media files to FormData:", data.mediaFiles.length, "files");
          for (let i = 0; i < data.mediaFiles.length; i++) {
            formData.append('media', data.mediaFiles[i]);
          }
        }

        // Clean up contact info fields
        const cleanContactInfo = data.contactInfo ? Object.fromEntries(
          Object.entries(data.contactInfo)
            .filter(([_, value]) => value && value.trim() !== '')
        ) : undefined;

        // Prepare the event data
        const eventData = {
          title: data.title.trim(),
          startDate: new Date(data.startDate).toISOString(),
          endDate: new Date(data.endDate).toISOString(),
          location: data.location.trim(),
          description: data.description?.trim() || undefined,
          category: data.category,
          businessName: data.businessName?.trim() || undefined,
          contactInfo: Object.keys(cleanContactInfo || {}).length > 0 ? cleanContactInfo : undefined,
          // Include badge required field
          badgeRequired: data.badgeRequired === true,
          // Handle the hours of operation, explicitly converting between string 'null' and actual null
          hoursOfOperation: data.hoursOfOperation === 'null' || data.hoursOfOperation === null ? 
            null : // Important: Set to real null when the hours are toggled off
            (data.hoursOfOperation ? 
              (typeof data.hoursOfOperation === 'string' ? 
                JSON.parse(data.hoursOfOperation) : 
                data.hoursOfOperation) : 
              undefined),
          mediaUrls: data.mediaUrls || [],
          // Handle recurring event data
          isRecurring: data.isRecurring,
          recurrenceFrequency: data.isRecurring && data.recurrenceFrequency ? 
            // Normalize frequency: convert to lowercase and replace "bi-weekly" with "biweekly"
            data.recurrenceFrequency.toLowerCase().replace('bi-weekly', 'biweekly') : null,
          recurrenceEndDate: data.isRecurring && data.recurrenceEndDate ? 
            new Date(data.recurrenceEndDate).toISOString() : null
        };
        
        console.log("Final eventData for new event:", eventData);

        // Add the event data as a JSON string
        formData.append('eventData', JSON.stringify(eventData));

        console.log("Sending POST request to create new event");
        // Use apiRequest for consistent authentication handling
        const response = await apiRequest({
          url: `/api/events`,
          method: 'POST',
          body: formData
        });
        
        if (!response.ok) {
          const contentType = response.headers.get("content-type");
          if (contentType?.includes("application/json")) {
            const errorData = await response.json();
            console.error("Event creation error response:", errorData);
            throw new Error(errorData.message || "Failed to create event");
          }
          throw new Error(`Failed to create event: ${response.status} ${response.statusText}`);
        }

        console.log("Event creation successful");
        return response.json();
      } catch (error) {
        console.error("Error in createEventMutation.mutationFn:", error);
        throw error;
      }
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["/api/events"] });
      setIsCreateDuplicateDialogOpen(false);
      toast({
        title: "Success",
        description: "Event duplicated successfully"
      });
      // Navigate to the new event page
      if (data && data.id) {
        setLocation(`/events/${data.id}`);
      }
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive"
      });
    }
  });

  const deleteMutation = useMutation({
    mutationFn: async () => {
      // Use apiRequest for consistent authentication handling
      const response = await apiRequest({
        url: `/api/events/${id}`,
        method: 'DELETE'
      });
      if (!response.ok) {
        throw new Error("Failed to delete event");
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/events"] });
      queryClient.invalidateQueries({ queryKey: ["/api/events", parseInt(id)] });
      toast({
        title: "Success",
        description: "Event deleted successfully",
      });
      setLocation("/calendar");
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });
  
  // Mutation for deleting an entire recurring event series
  const deleteSeriesMutation = useMutation({
    mutationFn: async () => {
      console.log("Deleting entire event series with ID:", id);
      // Use apiRequest for consistent authentication handling
      const response = await apiRequest({
        url: `/api/events/${id}/series`,
        method: 'DELETE'
      });
      if (!response.ok) {
        throw new Error("Failed to delete event series");
      }
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/events"] });
      toast({
        title: "Success",
        description: "Event series deleted successfully",
      });
      setLocation("/calendar");
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const interestedUsers = interactions.filter(i => i.interactionType === "interested");
  const goingUsers = interactions.filter(i => i.interactionType === "going");
  const likedUsers = interactions.filter(i => i.interactionType === "like");

  const userInteraction = user && interactions.find(i => i.userId === user.id);

  const formatDate = (dateString: string | null | undefined) => {
    if (!dateString) return "";
    try {
      // Validate the date string before creating a Date object
      const timestamp = Date.parse(dateString);
      if (isNaN(timestamp)) {
        console.error("Invalid date string:", dateString);
        return "Invalid date";
      }
      
      const dateObj = new Date(timestamp);
      // Check if date is valid after parsing
      if (isNaN(dateObj.getTime())) {
        console.error("Invalid date object after parsing:", dateString);
        return "Invalid date";
      }
      
      return format(dateObj, "PPP");
    } catch (error) {
      console.error("Date formatting error:", error, "for date string:", dateString);
      return "Invalid date";
    }
  };

  if (isEventLoading) {
    return <div className="text-center p-8">Loading event details...</div>;
  }

  if (eventError || !event) {
    return (
      <div className="text-center p-8">
        <p className="text-xl text-red-600 mb-4">Failed to load event details</p>
        <Button onClick={() => setLocation("/calendar")}>Return to Calendar</Button>
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto space-y-8 p-4">
      {isAdmin && (
        <div className="flex justify-end gap-4">
          {/* Duplicate Event Button */}
          <Button
            variant="outline"
            onClick={() => setIsCreateDuplicateDialogOpen(true)}
            className="gap-2 mr-auto" // mr-auto pushes it to the left
          >
            <CalendarDays className="h-4 w-4" />
            Duplicate Event
          </Button>
          
          {/* Alert Dialog for Recurring Event Edit Options */}
          <AlertDialog open={isRecurringEditDialogOpen} onOpenChange={setIsRecurringEditDialogOpen}>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Edit Recurring Event</AlertDialogTitle>
                <AlertDialogDescription>
                  Would you like to edit only this occurrence or the entire series?
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter className="flex flex-col sm:flex-row gap-2">
                <div className="flex flex-wrap gap-2 justify-between w-full">
                  <Button
                    variant="outline"
                    onClick={() => {
                      setEditMode('occurrence');
                      setIsRecurringEditDialogOpen(false);
                      setIsEditDialogOpen(true);
                    }}
                  >
                    Edit Only Occurrence
                  </Button>
                  <Button
                    onClick={() => {
                      setEditMode('series');
                      setIsRecurringEditDialogOpen(false);
                      setIsEditDialogOpen(true);
                    }}
                  >
                    Edit Recurring Series
                  </Button>
                </div>
                <div className="w-full border-t border-border pt-2 mt-2">
                  <Button
                    variant="destructive"
                    className="w-full gap-2"
                    onClick={() => {
                      setIsRecurringEditDialogOpen(false);
                      setIsDeleteSeriesDialogOpen(true);
                    }}
                  >
                    <Trash2 className="h-4 w-4" />
                    Delete Series
                  </Button>
                </div>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
          
          {/* Alert Dialog for Delete Series Confirmation */}
          <AlertDialog open={isDeleteSeriesDialogOpen} onOpenChange={setIsDeleteSeriesDialogOpen}>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Delete Recurring Event Series</AlertDialogTitle>
                <AlertDialogDescription>
                  Are you sure you want to delete the entire series? This action cannot be undone and will delete all occurrences of this event.
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction
                  onClick={() => deleteSeriesMutation.mutate()}
                  className="bg-red-600 hover:bg-red-700"
                >
                  {deleteSeriesMutation.isPending ? "Deleting..." : "Delete Series"}
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
          
          <Dialog open={isEditDialogOpen} onOpenChange={setIsEditDialogOpen}>
            <Button
              variant="outline"
              onClick={() => {
                // Check if this is a recurring event
                if (event?.isRecurring) {
                  setIsRecurringEditDialogOpen(true);
                } else {
                  setEditMode(null); // Not a recurring event
                  setIsEditDialogOpen(true);
                }
              }}
              className="gap-2"
            >
              <Pencil className="h-4 w-4" />
              Edit Event
            </Button>
            <DialogContent className="sm:max-w-[700px] max-h-[80vh] overflow-y-auto">
              <DialogHeader>
                <DialogTitle>
                  Edit Event {event?.isRecurring && editMode === 'occurrence' ? '(This Occurrence Only)' : ''}
                  {event?.isRecurring && editMode === 'series' ? '(Entire Series)' : ''}
                </DialogTitle>
                <DialogDescription>
                  Update event details. Fields marked with * are required.
                </DialogDescription>
              </DialogHeader>
              {event && (
                <CreateEventForm
                  defaultValues={{
                    ...event,
                    startDate: new Date(event.startDate),
                    endDate: new Date(event.endDate),
                    // Convert hoursOfOperation from object to string for the form
                    hoursOfOperation: event.hoursOfOperation ? 
                      JSON.stringify(event.hoursOfOperation) : 
                      null,
                    // Convert recurrenceEndDate from string to Date if it exists
                    recurrenceEndDate: event.recurrenceEndDate ? 
                      new Date(event.recurrenceEndDate) : 
                      undefined,
                  }}
                  onSubmit={(data) => {
                    console.log("Form onSubmit called in event-detail-page with data:", data);
                    updateEventMutation.mutate(data);
                  }}
                  onDuplicate={() => {
                    console.log("Duplicate button clicked, opening duplicate dialog");
                    setIsEditDialogOpen(false);
                    setIsCreateDuplicateDialogOpen(true);
                  }}
                  isSubmitting={updateEventMutation.isPending}
                />
              )}
            </DialogContent>
          </Dialog>

          <AlertDialog>
            <AlertDialogTrigger asChild>
              <Button variant="destructive" className="gap-2">
                <Trash2 className="h-4 w-4" />
                Delete Event
              </Button>
            </AlertDialogTrigger>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                <AlertDialogDescription>
                  This action cannot be undone. This will permanently delete this event
                  and remove it from the calendar.
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction
                  onClick={() => deleteMutation.mutate()}
                  className="bg-red-600 hover:bg-red-700"
                >
                  {deleteMutation.isPending ? "Deleting..." : "Delete"}
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>

          {/* Duplicate Event Dialog */}
          <Dialog open={isCreateDuplicateDialogOpen} onOpenChange={setIsCreateDuplicateDialogOpen}>
            <DialogContent className="sm:max-w-[700px] max-h-[80vh] overflow-y-auto">
              <DialogHeader>
                <DialogTitle>Create Duplicate Event</DialogTitle>
                <DialogDescription>
                  Create a copy of this event with new dates and times. All other details will be preserved.
                </DialogDescription>
              </DialogHeader>
              {event && (
                <CreateEventForm
                  defaultValues={{
                    ...event,
                    // For a duplicate, start with current dates but advance them by a day
                    startDate: new Date(new Date(event.startDate).setDate(new Date(event.startDate).getDate() + 1)),
                    endDate: new Date(new Date(event.endDate).setDate(new Date(event.endDate).getDate() + 1)),
                    // Convert hoursOfOperation from object to string for the form
                    hoursOfOperation: event.hoursOfOperation ? 
                      JSON.stringify(event.hoursOfOperation) : 
                      null,
                    // Convert recurrenceEndDate from string to Date if it exists
                    recurrenceEndDate: event.recurrenceEndDate ? 
                      new Date(event.recurrenceEndDate) : 
                      undefined,
                  }}
                  onSubmit={(data) => {
                    console.log("Creating duplicate event with data:", data);
                    createEventMutation.mutate(data);
                  }}
                  isSubmitting={createEventMutation.isPending}
                />
              )}
            </DialogContent>
          </Dialog>
        </div>
      )}

      {/* Event Information Section */}
      <Card>
        <CardHeader>
          <CardTitle className="text-3xl break-words min-w-0 pr-4">{event.title}</CardTitle>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="flex flex-col lg:flex-row gap-8">
            {/* Left side: Event Details */}
            <div className="flex-1 space-y-6">
              <div className="flex flex-col gap-4">
                <div className="flex items-center gap-3 text-lg">
                  <CalendarDays className="h-5 w-5 text-muted-foreground" />
                  <span>{formatDate(event.startDate?.toString())}</span>
                </div>

                <div className="flex items-center gap-3 text-lg">
                  <Clock className="h-5 w-5 text-muted-foreground" />
                  <span>
                    {(() => {
                      try {
                        // Check if startDate or endDate is undefined
                        if (!event.startDate || !event.endDate) {
                          return "Time information unavailable";
                        }
                        
                        const startTime = new Date(event.startDate);
                        const endTime = new Date(event.endDate);
                        
                        // Validate both dates before formatting
                        if (isNaN(startTime.getTime()) || isNaN(endTime.getTime())) {
                          return "Time information unavailable";
                        }
                        
                        return `${format(startTime, "h:mm a")} - ${format(endTime, "h:mm a")}`;
                      } catch (error) {
                        return "Time information unavailable";
                      }
                    })()}
                  </span>
                </div>

                {event.location && (
                  <div className="flex items-center gap-3 text-lg">
                    <MapPin className="h-5 w-5 text-muted-foreground" />
                    <span>{event.location}</span>
                  </div>
                )}
                
                {/* Add website field below location */}
                {event.contactInfo?.website && (
                  <div className="flex items-center gap-3 text-lg">
                    <Globe className="h-5 w-5 text-muted-foreground" />
                    <a href={event.contactInfo.website} target="_blank" rel="noopener noreferrer" className="hover:underline">
                      {event.contactInfo.website}
                    </a>
                  </div>
                )}
                
                {/* Badge Required Indicator */}
                <div className="flex items-center gap-3 text-lg mt-2">
                  {event.badgeRequired ? (
                    <>
                      <CreditCard className="h-5 w-5 text-primary" />
                      <span className="flex items-center gap-2">
                        <Badge variant="outline" className="bg-primary text-white border-primary/20 font-medium px-2">
                          Badge Required
                        </Badge>
                      </span>
                    </>
                  ) : (
                    <>
                      <BanIcon className="h-5 w-5 text-muted-foreground" />
                      <span className="flex items-center gap-2">
                        <Badge variant="outline" className="bg-muted text-muted-foreground border-muted/30 font-medium px-2">
                          No Badge Required
                        </Badge>
                      </span>
                    </>
                  )}
                </div>
              </div>

              {event.description && (
                <div className="mt-6">
                  <h3 className="text-lg font-semibold mb-2">Description</h3>
                  <p className="text-lg">{event.description}</p>
                </div>
              )}

              {/* Only show Hours of Operation if it was explicitly set (not hidden) */}
              {event.hoursOfOperation !== null &&
                typeof event.hoursOfOperation === 'object' &&
                Object.keys(event.hoursOfOperation).length > 0 && (
                  <div className="mt-6">
                    <h3 className="text-lg font-semibold mb-2">Hours of Operation</h3>
                    <div className="whitespace-pre-line">
                      {formatHoursOfOperation(event.hoursOfOperation)}
                    </div>
                  </div>
                )}
            </div>

            {/* Right side: Map and Media Gallery */}
            <div className="lg:w-1/3 space-y-6">
              {/* Map Section */}
              {event.location && (
                <div>
                  <Badge 
                    variant="secondary" 
                    className={`mb-4 ${
                      event.category === 'entertainment' 
                        ? 'bg-[#47759a] text-white' 
                        : event.category === 'government'
                        ? 'bg-[#e9dfe0] text-navy'
                        : event.category === 'social'
                        ? 'bg-[#efe59c] text-navy'
                        : 'bg-gray-200 text-gray-900'
                    } font-semibold text-base`}
                  >
                    {event.category === 'entertainment' 
                      ? 'Entertainment & Activities'
                      : event.category === 'government'
                      ? 'Government & Politics'
                      : event.category === 'social'
                      ? 'Social Clubs'
                      : 'Other'}
                  </Badge>
                  <h3 className="text-lg font-semibold mb-4">Location</h3>
                  <LocationMapAlt
                    location={event.location}
                    className="w-full h-[200px]"
                  />
                </div>
              )}

              {/* Media Gallery Section */}
              {event.mediaUrls && event.mediaUrls.length > 0 && (
                <div>
                  <h3 className="text-lg font-semibold mb-4">Photos & Videos</h3>
                  <EventMediaGallery mediaUrls={event.mediaUrls} />
                </div>
              )}
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Contact Information Section */}
      {(event.businessName || event.contactInfo) && (
        <Card>
          <CardHeader className="pb-2">
            <div className="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-2">
              <CardTitle>Contact Information</CardTitle>
              <div className="flex items-center gap-2">
                <Label htmlFor="show-contact-info" className="text-sm text-muted-foreground whitespace-nowrap">
                  {showContactInfo ? (
                    <div className="flex items-center gap-1">
                      <Eye className="h-4 w-4" />
                      <span>Show</span>
                    </div>
                  ) : (
                    <div className="flex items-center gap-1">
                      <EyeOff className="h-4 w-4" />
                      <span>Hide</span>
                    </div>
                  )}
                </Label>
                <Switch
                  id="show-contact-info"
                  checked={showContactInfo}
                  onCheckedChange={setShowContactInfo}
                />
              </div>
            </div>
          </CardHeader>
          <CardContent className="space-y-4">
            {event.businessName && (
              <div className="flex items-center gap-3 text-lg">
                <Building2 className="h-5 w-5 text-muted-foreground" />
                <span>{event.businessName}</span>
              </div>
            )}

            {event.contactInfo?.name && (
              <div className="flex items-center gap-3 text-lg">
                <Users className="h-5 w-5 text-muted-foreground" />
                <span>{event.contactInfo.name}</span>
              </div>
            )}

            {event.contactInfo?.phone && (
              <div className="flex items-center gap-3 text-lg">
                <Phone className="h-5 w-5 text-muted-foreground" />
                {showContactInfo ? (
                  <a href={`tel:${event.contactInfo.phone}`} className="hover:underline">
                    {event.contactInfo.phone}
                  </a>
                ) : (
                  <span>••••••••••</span>
                )}
              </div>
            )}

            {event.contactInfo?.email && (
              <div className="flex items-center gap-3 text-lg">
                <Mail className="h-5 w-5 text-muted-foreground" />
                {showContactInfo ? (
                  <a href={`mailto:${event.contactInfo.email}`} className="hover:underline">
                    {event.contactInfo.email}
                  </a>
                ) : (
                  <span>••••••••••</span>
                )}
              </div>
            )}

            {/* Website field moved to main event information section */}
          </CardContent>
        </Card>
      )}

      {/* Interaction Buttons Section */}
      <div className="space-y-6">
        <div className="flex flex-wrap gap-4">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <span>
                  <Button
                    variant={userInteraction?.interactionType === "like" ? "default" : "outline"}
                    className="text-lg py-6 px-8"
                    onClick={() => interactionMutation.mutate("like")}
                    disabled={!user || interactionMutation.isPending || (user && !canInteractWithEvent && !isAdmin)}
                  >
                    <ThumbsUp className="mr-2" />
                    Like ({likedUsers.length})
                  </Button>
                </span>
              </TooltipTrigger>
              {user && !canInteractWithEvent && !isAdmin && (
                <TooltipContent className="max-w-xs">
                  <div className="flex items-center gap-2">
                    <AlertTriangle className="h-4 w-4 text-amber-500" />
                    <p>Your account requires approval before you can interact with events.</p>
                  </div>
                </TooltipContent>
              )}
            </Tooltip>
          </TooltipProvider>

          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <span>
                  <Button
                    variant={userInteraction?.interactionType === "going" ? "default" : "outline"}
                    className="text-lg py-6 px-8"
                    onClick={() => interactionMutation.mutate("going")}
                    disabled={!user || interactionMutation.isPending || (user && !canInteractWithEvent && !isAdmin)}
                  >
                    <Users className="mr-2" />
                    I'm Going ({goingUsers.length})
                  </Button>
                </span>
              </TooltipTrigger>
              {user && !canInteractWithEvent && !isAdmin && (
                <TooltipContent className="max-w-xs">
                  <div className="flex items-center gap-2">
                    <AlertTriangle className="h-4 w-4 text-amber-500" />
                    <p>Your account requires approval before you can interact with events.</p>
                  </div>
                </TooltipContent>
              )}
            </Tooltip>
          </TooltipProvider>

          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <span>
                  <Button
                    variant={userInteraction?.interactionType === "interested" ? "default" : "outline"}
                    className="text-lg py-6 px-8"
                    onClick={() => interactionMutation.mutate("interested")}
                    disabled={!user || interactionMutation.isPending || (user && !canInteractWithEvent && !isAdmin)}
                  >
                    <Users className="mr-2" />
                    Interested ({interestedUsers.length})
                  </Button>
                </span>
              </TooltipTrigger>
              {user && !canInteractWithEvent && !isAdmin && (
                <TooltipContent className="max-w-xs">
                  <div className="flex items-center gap-2">
                    <AlertTriangle className="h-4 w-4 text-amber-500" />
                    <p>Your account requires approval before you can interact with events.</p>
                  </div>
                </TooltipContent>
              )}
            </Tooltip>
          </TooltipProvider>
        </div>

        {interactions.length > 0 && (
          <UserAvatarCarousel interactions={interactions} />
        )}
      </div>

      {/* Comments Section */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <MessageSquare className="h-5 w-5" />
            Comments ({comments.length})
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-6">
          {user ? (
            user && !canCommentOnEvent && !isAdmin ? (
              <div className="p-4 bg-amber-50 border border-amber-200 rounded-md">
                <div className="flex items-center gap-3 mb-2">
                  <AlertTriangle className="h-5 w-5 text-amber-500" />
                  <p className="font-medium text-amber-800">Commenting Restricted</p>
                </div>
                <p className="text-amber-700">
                  You don't have permission to post comments. 
                  {user.isBlocked && user.blockReason ? ` Reason: ${user.blockReason}` : 
                  ' This could be due to account restrictions or you may need a specific membership level.'}
                </p>
              </div>
            ) : (
              <div className="space-y-4">
                <Textarea
                  placeholder="Write a comment..."
                  value={comment}
                  onChange={(e) => setComment(e.target.value)}
                  className="text-lg"
                />
                <Button
                  onClick={() => commentMutation.mutate(comment)}
                  disabled={!comment.trim() || commentMutation.isPending}
                  className="text-lg py-6"
                >
                  Post Comment
                </Button>
              </div>
            )
          ) : (
            <p className="text-muted-foreground">Please login to comment</p>
          )}

          <div className="space-y-4">
            {comments.map((comment) => (
              <div key={comment.id} className="flex gap-4">
                <div className="flex-shrink-0">
                  {comment.user ? (
                    <UserAvatar 
                      user={{
                        username: comment.user.username,
                        avatarUrl: comment.user.avatarUrl,
                        isResident: comment.user.isResident
                      }}
                      size="md"
                      showBadge={true}
                      inComments={true}
                    />
                  ) : (
                    <Avatar>
                      <AvatarFallback>?</AvatarFallback>
                    </Avatar>
                  )}
                </div>
                <div className="flex-1">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                      <p className="font-semibold">{comment.user?.username ?? 'Anonymous'}</p>
                      <span className="text-sm text-muted-foreground">•</span>
                      <p className="text-sm text-muted-foreground">
                        {comment.createdAt ? format(new Date(comment.createdAt), "PPp") : ""}
                      </p>
                    </div>
                    {isAdmin && (
                      <TooltipProvider>
                        <Tooltip>
                          <TooltipTrigger asChild>
                            <Button 
                              variant="ghost" 
                              size="sm" 
                              className="text-red-500 hover:text-red-700 hover:bg-red-50 p-1 h-auto"
                              onClick={() => deleteCommentMutation.mutate(comment.id)}
                              disabled={deleteCommentMutation.isPending}
                            >
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          </TooltipTrigger>
                          <TooltipContent>
                            <p>Delete comment</p>
                          </TooltipContent>
                        </Tooltip>
                      </TooltipProvider>
                    )}
                  </div>
                  <p className="mt-2 text-gray-700">{comment.content}</p>
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}